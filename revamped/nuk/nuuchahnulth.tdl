;;; -*- Mode: TDL; Coding: utf-8 -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Grammar of Nuuchahnulth
;;; created at:
;;;     Tue Mar 05 01:01:33 UTC 2019
;;; based on Matrix customization system version of:
;;;     Tue Nov 13 21:13:22 UTC 2018
;;;
;;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Type assigning empty mod list. Added to basic types for nouns, verbs and determiners.

non-mod-lex-item := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < > ].

;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Matrix Type Addenda
;;;;;;;;;;;;;;;;;;;;;;;;;

;;; 2019-03-12 removing PRD - already defined in GM (!)
;;; 2019-03-19 adding TYPE-RAISE bool to avoid looping
head :+ [ PRON bool,
    AUX bool,
    TYPE-RAISE bool,
    NMZ bool,
    POSSESSOR poss,
    INIT bool,
    SPEC-INIT bool,
    FORM form,
    HTYPE htype ].

root := form.
non-root := form.
uu-form := root & non-root.
root-finite := root & finite.
root-nonfinite := root & nonfinite.
non-root-finite := non-root & finite.
non-root-nonfinite := non-root & nonfinite.

;;; 2019-04-04 Root to non-root and non-root to root

root-to-non-root-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRON #pron,
                            AUX #aux,
                            TYPE-RAISE #TYPE-RAISE,
                            NMZ #nmz,
                            POSSESSOR #poss,
                            INIT #init,
                            SPEC-INIT #spec-init,
                            MOD #mod,
                            PRD #prd,
                            KEYS #keys,
                            HTYPE #htype,
                            FORM non-root ],
    DTR.SYNSEM.LOCAL.CAT.HEAD [ PRON #pron,
                                AUX #aux,
                                TYPE-RAISE #TYPE-RAISE,
                                NMZ #nmz,
                                POSSESSOR #poss,
                                INIT #init,
                                SPEC-INIT #spec-init,
                                MOD #mod,
                                PRD #prd,
                                KEYS #keys,
                                HTYPE #htype,
                                FORM root ] ].

non-root-to-root-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD [ PRON #pron,
                            AUX #aux,
                            TYPE-RAISE #TYPE-RAISE,
                            NMZ #nmz,
                            POSSESSOR #poss,
                            INIT #init,
                            SPEC-INIT #spec-init,
                            MOD #mod,
                            PRD #prd,
                            KEYS #keys,
                            HTYPE #htype,
                            FORM root ],
    DTR.SYNSEM.LOCAL.CAT.HEAD [ PRON #pron,
                                AUX #aux,
                                TYPE-RAISE #TYPE-RAISE,
                                NMZ #nmz,
                                POSSESSOR #poss,
                                INIT #init,
                                SPEC-INIT #spec-init,
                                MOD #mod,
                                PRD #prd,
                                KEYS #keys,
                                HTYPE #htype,
                                FORM non-root ] ].

;;; 2019-03-13 I need a type of list that is either POSTHEAD + or empty

phlist := list.

phcons := phlist & cons &
  [ FIRST synsem-min & [ LOCAL.CAT.POSTHEAD + ],
    REST  phlist ].

; 2019-03-30 NB: Needs to inherit from olist because null is also optional :)
phnull := phlist & null & olist.

;;; 2019-03-06 adding perfective values to aspect

aspect :+ [ PERF bool ].

lex-or-phrase-synsem :+ [ INFOSTR-FLAG luk ].

; 2019-03-22 making sure that the subj is not an adv with MOD < >
decl-head-subj-phrase :+ [ SYNSEM.INFOSTR-FLAG -, NON-HEAD-DTR.SYNSEM [ INFOSTR-FLAG -,
                                                                        LOCAL.CAT.HEAD.MOD < > ] ].

basic-head-1st-comp-phrase :+ [ SYNSEM.INFOSTR-FLAG -, NON-HEAD-DTR.SYNSEM.INFOSTR-FLAG - ].

basic-head-2nd-comp-phrase :+ [ SYNSEM.INFOSTR-FLAG -, NON-HEAD-DTR.SYNSEM.INFOSTR-FLAG - ].

basic-head-opt-subj-phrase :+ [ SYNSEM.INFOSTR-FLAG - ].

; 2019-03-22 restricting daughter to be subj empty so this applies last (spurious ambiguity)
; 2019-05-10 passing up mod (don't know why it isn't by default)
basic-head-opt-comp-phrase :+ [ SYNSEM [ INFOSTR-FLAG -,
                                         LOCAL.CAT.HEAD.MOD #mod ],
                                HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.MOD #mod,
                                                            VAL.SUBJ < [ ] > ] ].
; Removing this as it is making dropping impossible!
;                                HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < > ].

basic-head-mod-phrase-simple :+ [ SYNSEM.INFOSTR-FLAG - ].

basic-head-spec-phrase :+ [ SYNSEM.INFOSTR-FLAG - ].

basic-bare-np-phrase :+ [ SYNSEM.INFOSTR-FLAG -, HEAD-DTR.SYNSEM.INFOSTR-FLAG - ].

coord-phrase :+ [ SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz,
    LCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz,
    RCOORD-DTR.SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz ].

unary-bottom-coord-rule :+ [ SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz,
    ARGS < [ SYNSEM.LOCAL.CAT.HEAD.NMZ #nmz ] > ].

inflected :+ [ CONTINUATIVE-FORM-FLAG luk,
    ITERATIVE-FORM-FLAG luk,
    MOMENTANEOUS-FORM-FLAG luk,
    REPETITIVE-FORM-FLAG luk,
    INCEPTIVE-FORM-FLAG luk,
    INCEPTIVE-COMPLEX-FLAG luk,
    ASPECT-2-FLAG luk,
    MOMENTANEOUS-COMPLEX-FLAG luk,
    DURATIVE-FORM-FLAG luk,
    PRE-CLITIC-PAST-FLAG luk,
    ASPECT-1-FLAG luk,
    SOME-INFLECTION luk,
    INCORPORATION-FLAG luk ].

infl-satisfied :+ [ CONTINUATIVE-FORM-FLAG na-or-+,
    ITERATIVE-FORM-FLAG na-or-+,
    MOMENTANEOUS-FORM-FLAG na-or-+,
    REPETITIVE-FORM-FLAG na-or-+,
    INCEPTIVE-FORM-FLAG na-or-+,
    INCEPTIVE-COMPLEX-FLAG na-or-+,
    ASPECT-2-FLAG na-or-+,
    MOMENTANEOUS-COMPLEX-FLAG na-or-+,
    DURATIVE-FORM-FLAG na-or-+,
    PRE-CLITIC-PAST-FLAG na-or-+,
    ASPECT-1-FLAG na-or-+,
    SOME-INFLECTION na-or-+,
    INCORPORATION-FLAG na-or-+ ].

png :+ [ PER person,
    NUM number ].

cat :+ [ POSSESSUM poss ].

poss := *top* &
  [ POSS-AGR png ].

basic-bare-np-phrase :+ [ SYNSEM.LOCAL.CAT [ VAL.SPEC < >,
                       HEAD #head,
                       POSSESSUM #possessum ],
    HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD #head,
                                POSSESSUM #possessum & nonpossessive ] ].

basic-head-1st-comp-phrase :+ [ SYNSEM.LOCAL.CAT.POSSESSUM #poss,
    HEAD-DTR.SYNSEM.LOCAL.CAT.POSSESSUM #poss ].

basic-head-opt-subj-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

basic-determiner-lex :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR nonpossessive,
                       POSSESSUM nonpossessive ] ].

top-coord-rule :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                       POSSESSUM #possessum ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ] ].

mid-coord-rule :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                       POSSESSUM #possessum ],
    RCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ],
    LCOORD-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                  POSSESSUM #possessum ] ].

bottom-coord-phrase :+ [ SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                       POSSESSUM #possessum ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD.POSSESSOR #possessor,
                                   POSSESSUM #possessum ] ].

;;; 2019-03-09 opt subj & comp should only apply to finite verbs (i.e., with the clitic attached)
;;; 2019-03-09 should only be compatible with things headed by AUX
;;; 2019-04-01 constraining daughter to have no SLASH
nuk-head-opt-subj-phrase := decl-head-opt-subj-phrase &
[ HEAD-DTR.SYNSEM [ LOCAL.CAT [ HEAD [ FORM finite,
                                      AUX + ],
                                VAL.SUBJ < synsem-min > ],
                    NON-LOCAL.SLASH <! !> ] ].

nuk-head-opt-subj-imp-phrase := imp-head-opt-subj-phrase &
[ HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD [ FORM finite,
                                   AUX + ],
                    NON-LOCAL.SLASH <! !> ] ].

;;; TODO this needs to apply either low or high but not both, for now must be high
;;; 2019-05-06 forcing it to apply low b/c I need to drop comps in SVCs
;;; 2019-05-06 needs to apply in both places. commenting out... :/
nuk-head-opt-comp-phrase := basic-head-opt-comp-phrase &
[ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.FORM finite ] ].

;;;;;;;;;;;;;;
;;; Features
;;;;;;;;;;;;;;

;;; Person

person := *top*.
1st := person.
2nd := person.
3rd := person.

;;; Number

number := *top*.
singular := number.
plural := number.

;;; Possession

possession := *top*.
possessive := poss.  ; supertype for possessive features
nonpossessive := poss.  ; type for nonpossessive
possessor := possessive.
possessum := possessive.
possessive-1 := possessive.  ; supertype for strategy 1
possessor-1 := possessor & possessive-1.
possessum-1 := possessum & possessive-1.

;;; Possession

possessive-2 := possessive.  ; supertype for strategy 2
possessor-2 := possessor & possessive-2.
possessum-2 := possessum & possessive-2.

;;; Form

form := *top*.
nonfinite := form.
finite := form.
finite-aux := nonfinite.

;;; 2019-05-10
;;; htype
htype := *top*.
location := htype.
non-location := htype.
adpositive := non-location.
normal := non-location.

;;; Tense

past := tense.
future := tense.

;;; Aspect

meaning := aspect.
habitual := aspect.
xperf := aspect.
perfective := xperf & [ PERF + ].
imperfective := xperf & [ PERF - ].
momentaneous := meaning.
inceptive := meaning.
continuative := meaning.
durative := meaning.
repetitive := meaning.
iterative := meaning.
MO := momentaneous & perfective.
IN := continuative & perfective.
CT := continuative & imperfective.
DR := durative & imperfective.
RP := repetitive & imperfective.
IT := iterative & imperfective.
MO-GRAD := momentaneous & imperfective.
IN-GRAD := inceptive & imperfective.
start := meaning.
MO-GRAD-PF := MO & start.
IN-GRAD-PF := IN & start.
DR-PF := durative & perfective.
RP-PF := repetitive & perfective.
IT-PF := iterative & perfective.

;;; 2019-03-06 habitual forms of every aspect
MO-HABIT := MO & habitual.
IN-HABIT := IN & habitual.
CT-HABIT := CT & habitual.
DR-HABIT := DR & habitual.
RP-HABIT := RP & habitual.
IT-HABIT := IT & habitual.
MO-GRAD-HABIT := MO-GRAD & habitual.
IN-GRAD-HABIT := IN-GRAD & habitual.
MO-GRAD-PF-HABIT := MO-GRAD-PF & habitual.
IN-GRAD-PF-HABIT := IN-GRAD-PF & habitual.
DR-PF-HABIT := DR-PF & habitual.
RP-PF-HABIT := RP-PF & habitual.
IT-PF-HABIT := IT-PF & habitual.


;;; Mood

; 2019-04-23 ugly hack to make things non-definite
strong-real := non-definite.
weak := non-definite.
neutral := non-definite.
unknown := non-definite.
possible := non-definite.
hearsay := non-definite.
inferential := non-definite.
purposive := non-definite.
dubitative := non-definite.

non-definite := mood.
definite := mood.

;;;;;;;;;;;;;;;;;;;
;;; Lexical Types
;;;;;;;;;;;;;;;;;;;

predicate-lex := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD + ].

non-predicate-lex := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

uu-lex := lex-item.

main-clause-lex := lex-item &
  [ SYNSEM.LOCAL.CAT.MC + ].

subordinate-clause-lex := lex-item &
  [ SYNSEM.LOCAL.CAT.MC - ].

;;; Nouns

;;; 2019-03-12 making the ARG1 the XARG
nuk-basic-noun-lex := norm-sem-lex-item & basic-icons-lex-item & 
  [ SYNSEM [ LOCAL [ CAT.HEAD noun & [ AUX - ],
                     CONT.HOOK.XARG #xarg ],
             LKEYS.KEYREL arg1-ev-relation & [ ARG1 #xarg ] ] ].

;;; 2019-03-12 nouns are events with subjects.
noun-lex := nuk-basic-noun-lex & no-hcons-lex-item & non-mod-lex-item & predicate-lex & 
  [ ARG-ST < #subj & 
             [ LOCAL [ CAT cat-sat & [ VAL [ SPR < >,
                                             COMPS < > ]],
                       CONT.HOOK.INDEX #xarg ]] >,
    SYNSEM.LOCAL [ CAT [ VAL [ SPR < >,
                               COMPS < >,
                               SUBJ < #subj >,
                               SPEC < > ],
                         HEAD [ NMZ -,
                                POSSESSOR nonpossessive ],
                         POSSESSUM nonpossessive ],
                   CONT.HOOK.XARG #xarg ] ].

;;; 2019-03-12 the article is no longer a spr
;;; adding 3rd person information to common nouns
;no-spr-noun-lex := noun-lex &
;  [ SYNSEM.LOCAL.CAT.VAL.SPR < [ OPT + ] > ].

; 2019-04-03 this is blocking things like "I was a child"!!!!
;common-noun-noun-lex := noun-lex.

common-noun-word-and-root-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM root,
    INFLECTED infl-satisfied ].

common-noun-word-and-non-root-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM non-root,
    INFLECTED infl-satisfied ].

; 2019-05-10
common-noun-root-only-lex := noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM root,
    INFLECTED.SOME-INFLECTION - ].

;  [ SYNSEM.LOCAL.CONT.HOOK.XARG.PNG.PER 3rd ].

;;; 2019-03-12 This should actually be the "normal" noun-lex!
;;; TODO: make this PRD -
proper-noun-lex := basic-noun-lex & no-hcons-lex-item & non-mod-lex-item &  
  [ ARG-ST < >,
    SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < >,
                             SPEC < > ],
                       HEAD [ NMZ -,
                              PRD -,
                              POSSESSOR nonpossessive,
                              FORM non-root ],
                       POSSESSUM nonpossessive ] ].


plural-noun-lex := common-noun-word-and-non-root-lex &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ].

;;; 2019-03-12 Should probably rename this from proper-noun but they are similar in nuk
pronoun-pred-noun-lex := proper-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.PRON + ].

proper-noun-noun-lex := proper-noun-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.PRD -,
                   CONT.HOOK.INDEX.PNG.PER 3rd ] ].

pronoun-pred-1pl-noun-lex := pronoun-pred-noun-lex.

;;; 2019-03-12 Should probably rename this from proper-noun but they are similar in nuk
pronoun-doto-noun-lex := proper-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.PRON + ].

pronoun-doto-1pl-noun-lex := proper-noun-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.PRON + ].

pronoun-pred-2sg-noun-lex := pronoun-pred-noun-lex.

possessum-noun-lex-1 := basic-one-arg &
  [ ARG-ST < #comps >,
    SYNSEM.LOCAL [ CONT [ RELS <!  !>,
                          HCONS <!  !>,
                          HOOK #hook,
                          ICONS <!  !> ],
                   CAT [ VAL [ SUBJ < >,
                               COMPS < #comps &
                                       [ LOCAL [ CONT.HOOK #hook,
                                                 CAT [ POSSESSUM nonpossessive,
                                                       VAL.SPR < [ ] >,
                                                       HEAD #head &
                                                            [ PRON -,
                                                              POSSESSOR nonpossessive ] ] ] ] >,
                               SPR < [ LOCAL.CAT.HEAD det &
                                                      [ POSSESSOR possessor-1 ] ] > ],
                         POSSESSUM possessum-1,
                         HEAD #head & noun &
                              [ POSSESSOR nonpossessive,
                                INIT - ] ] ] ].

possessum-noun-lex-2 := basic-one-arg &
  [ ARG-ST < #comps >,
    SYNSEM.LOCAL [ CONT [ RELS <!  !>,
                          HCONS <!  !>,
                          HOOK #hook,
                          ICONS <!  !> ],
                   CAT [ VAL [ SUBJ < >,
                               COMPS < #comps &
                                       [ LOCAL [ CONT.HOOK #hook,
                                                 CAT [ POSSESSUM nonpossessive,
                                                       VAL.SPR < [ ] >,
                                                       HEAD #head &
                                                            [ PRON -,
                                                              POSSESSOR nonpossessive ] ] ] ] >,
                               SPR < [ LOCAL.CAT.HEAD det &
                                                      [ POSSESSOR possessor-2 ] ] > ],
                         POSSESSUM possessum-2,
                         HEAD #head & noun &
                              [ POSSESSOR nonpossessive,
                                INIT - ] ] ] ].

;;; Verbs

verb-lex := non-mod-lex-item & predicate-lex &
  [ SYNSEM.LOCAL.CAT.HEAD verb &
                          [ NMZ - ],
    INFLECTED [ CONTINUATIVE-FORM-FLAG na-or--,
                ITERATIVE-FORM-FLAG na-or--,
                MOMENTANEOUS-FORM-FLAG na-or--,
                REPETITIVE-FORM-FLAG na-or--,
                INCEPTIVE-FORM-FLAG na-or--,
                INCEPTIVE-COMPLEX-FLAG na-or--,
                DURATIVE-FORM-FLAG na-or--,
                MOMENTANEOUS-COMPLEX-FLAG na-or-- ] ].

main-verb-lex := verb-lex & basic-verb-lex &
  [ SYNSEM.LOCAL [ CAT [ HEAD.AUX -,
                         VAL [ SPR < >,
                               SPEC < >,
                               SUBJ < #subj > ] ],
                   CONT.HOOK.XARG #xarg ],
    ARG-ST.FIRST #subj &
                 [ LOCAL [ CAT cat-sat &
                               [ VAL [ SPR < >,
                                       COMPS < > ] ],
                           CONT.HOOK.INDEX #xarg ] ] ].

; 2019-05-11 bizarrely changing to AUX - because AUX means 2P AUX
; TODO: should have an AUX and 2P-AUX category!
aux-lex := verb-lex & 
  [ SYNSEM.LOCAL.CAT.HEAD [ AUX -,
                            FORM root-nonfinite ] ].

intransitive-verb-lex := main-verb-lex & intransitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    ARG-ST.FIRST.LOCAL.CAT.HEAD noun ].

;2019-04-01 complements should be to the right
transitive-verb-lex := main-verb-lex & transitive-lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
    ARG-ST < [ LOCAL.CAT.HEAD noun ],
             #comps &
             [ LOCAL.CAT cat-sat &
                         [ VAL [ SPR < >,
                                 COMPS < > ],
                           HEAD noun,
                           POSTHEAD + ] ] > ].

;;; 2019-03-06 Auxiliaries need to take predicates
;;; and compose their arguments
;;; TODO: Make sure that it unifies correctly, b/c
;;; emb's wambaya grammar has composition happening in
;;; the PSR - there is possibly a good reason for this
;;; TODO: Subj doesn't need to be head noun but head.prd -
;;; TODO: revisit FORM nonfinite
;2p-arg-comp-aux := lex-item &
; 2019-03-22 changing SUBJ to HEAD.PRD - not HEAD noun
; 2019-05-11 making first COMPS AUX - to avoid stacking
2p-lex := no-icons-lex-item & no-hcons-lex-item & post-clitic-also-rule-dtr & post-clitic-plural-rule-dtr & pre-clitic-causative-rule-dtr & pre-clitic-future-rule-dtr & pre-clitic-now-rule-dtr & pre-clitic-passive-rule-dtr & pre-clitic-poss-rule-dtr & post-clitic-habitual-lex-rule-dtr & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD [ FORM non-root-finite,
                                  AUX +,
                                  HTYPE #htype ],
           VAL [ SUBJ < #subj >,
                 COMPS < #comps . #vcomps >,
                 SPR < >,
                 SPEC < > ] ] ],
             NON-LOCAL #nonlocal ],
    ARG-ST < #subj &
       [ LOCAL [ CAT [ HEAD.PRD -,
           VAL.COMPS < > ] ]],
       #comps &
       [ LIGHT +,
         L-PERIPH +,
         OPT -,
         LOCAL [ CAT [ VAL [ SUBJ < #subj >,
                             COMPS #vcomps ],
                       HEAD [ PRD +,
                              AUX -,
                              FORM nonfinite,
                              HTYPE #htype ],
                       POSTHEAD - ] ],
         NON-LOCAL #nonlocal ]> ].

2p-lex-no-rels := 2p-lex &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < >,
                   CONT.RELS <! !> ] ].

2p-lex-no-rels-comp-xarg-raise := 2p-lex-no-rels & raise-sem-lex-item &
 [ ARG-ST < [ LOCAL.CONT.HOOK.INDEX #xarg ], [ LOCAL.CONT.HOOK.XARG #xarg ] > ].

;2p-lex-old := lex-item & 
;  [ SYNSEM [ LOCAL [ CAT [ HEAD [ AUX +,
;                                  MOD < > ],
;           VAL [ SUBJ < #subj >,
;                 COMPS < #comps . #vcomps >,
;                 SPR < >,
;                 SPEC < > ]],
;                     CONT [ RELS <! !>,
;                            HCONS <! !>,
;                            ICONS <! !> ] ],
;             NON-LOCAL #nonlocal ],
;    ARG-ST < #subj &
;       [ LOCAL [ CAT [ HEAD.PRD -,
;           VAL.COMPS < > ],
;           CONT.HOOK.INDEX #xarg ]],
;       #comps &
;       [ LIGHT +,
;         L-PERIPH +,
;         OPT -,
;         LOCAL [ CAT [ VAL [ SUBJ < #subj >,
;                             COMPS #vcomps ],
;                       HEAD [ PRD +,
;                              FORM nonfinite ],
;                       POSTHEAD - ],
;                 CONT.HOOK.XARG #xarg ],
;         NON-LOCAL #nonlocal ]> ].

;;; 2019-03-13
article-lex := 2p-lex-no-rels & non-predicate-lex & 
[ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #index & [ PNG.PER 3rd ],
                 CONT.HOOK.INDEX #index ] ].

;;; 2019-03-09 This is for the neutral mood applying w/ no further clitic-passive-lex-rule
;;; 2019-04-08 making parent LIGHT - b/c this (notionally) is no longer a single morpheme.
neutral-3rd-pred-lex-rule := same-non-local-lex-rule & same-modified-lex-rule & no-ccont-lex-rule & same-agr-lex-rule & same-ctxt-lex-rule & predicate-lex &
  [ SYNSEM [ LOCAL [ CAT [ HEAD verb &
                             [ AUX +,
                               MOD < >,
                               PRD +,
                               HTYPE #htype,
                               FORM non-root-finite ],
                           VAL [ SUBJ < #subj & [ LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] >,
                                 COMPS #comps,
                                 SPR #spr,
                                 SPEC #spec ]],
                     CONT [ HOOK [ GTOP #gtop,
                                   LTOP #ltop,
                                   INDEX #index & [ E.MOOD neutral,
                                                    SF prop ],
                                   XARG #xarg,
                                   ICONS-KEY #ikey,
                                   CLAUSE-KEY #ckey ],
                            RELS #rels,
                            HCONS #hcons,
                            ICONS #icons ]],
             LIGHT - ],
    DTR [ INFLECTED infl-satisfied,
         SYNSEM [ LOCAL [ CAT [ HEAD [ PRD +,
                                     FORM nonfinite,
                                     HTYPE #htype,
                                     AUX - ],
                                VAL [ SUBJ < #subj >,
                                      COMPS #comps,
                                      SPR #spr,
                                      SPEC #spec ]],
                       CONT [ HOOK [ GTOP #gtop,
                                     LTOP #ltop,
                                     INDEX #index,
                                     XARG #xarg,
                                     ICONS-KEY #ikey,
                                     CLAUSE-KEY #ckey ],
                              RELS #rels,
                              HCONS #hcons,
                              ICONS #icons ]],
                  LIGHT + ]],
    C-CONT [ RELS <!  !>,
             HCONS <!  !>,
             ICONS <!  !> ] ].

; 2019-04-01 this type raises adverbs as if they had a neutral mood on them
neutral-3rd-pred-adv-lex-rule := local-change-only-lex-rule & same-agr-lex-rule & same-ctxt-lex-rule & predicate-lex & 
  [ SYNSEM.LOCAL [ CAT [ HEAD verb &
                             [ AUX +,
                               TYPE-RAISE +,
                               MOD < >,
                               FORM non-root ],
                           VAL [ SUBJ < #subj & [ LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ] >,
                                 COMPS  < #mod & [ LIGHT +,
                                                   LOCAL [ CAT [ VAL [ SUBJ < #subj >,
                                                                       COMPS #vcomps & phlist ],
                                                                 HEAD verb & [ AUX -,
                                                                               TYPE-RAISE - ],
                                                                 POSTHEAD + ],
                                                           CONT.HOOK.INDEX #index & [ E.MOOD neutral,
                                                                                      SF prop ] ],
                                                   OPT - ] . #vcomps >,
                                 SPR < >,
                                 SPEC < > ] ],
                   CONT.HOOK.INDEX #index ],
    DTR [ INFLECTED infl-satisfied,
         SYNSEM.LOCAL [ CAT [ HEAD adv & [ TYPE-RAISE -,
                                           AUX -,
                                           MOD < #mod > ],
                              VAL [ SUBJ  < >,
                                    COMPS < >,
                                    SPR   < >,
                                    SPEC  < > ],
                              POSTHEAD - ] ] ],
    C-CONT [ RELS <!  !>,
             HCONS <!  !>,
             ICONS <!  !> ] ].

;;; TODO: This was generated by the GM, make sure that you
;;; don't still need it, then delete it
;2p-verb-lex := main-verb-lex & transitive-lex-item &
;  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comps >,
;    ARG-ST < [LOCAL.CAT.HEAD noun ],
;             #comps &
;             [ LOCAL.CAT cat-sat & 
;                      [ HEAD.PRD + ] ] > ].

htype-adpositive-verb-lex := verb-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.HTYPE adpositive ].

htype-location-verb-lex := verb-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.HTYPE location ].

htype-normal-verb-lex := verb-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.HTYPE normal ].

intransitive-verb-verb-lex-super := main-verb-verb-lex & intransitive-verb-lex.

intransitive-verb-verb-lex := intransitive-verb-verb-lex-super & htype-normal-verb-lex.

intransitive-verb-location-verb-lex := intransitive-verb-verb-lex-super & htype-location-verb-lex.

transitive-verb-verb-lex := main-verb-verb-lex & transitive-verb-lex & htype-normal-verb-lex.

;;; 2019-03-08 for the verbs that already have aspect & don't need more
intransitive-verb-inflected-lex := main-verb-inflected-lex & intransitive-verb-lex.

transitive-verb-inflected-lex := main-verb-inflected-lex & transitive-verb-lex.

;;;2019-03-08 adding infl satisfied to these!
;;;2019-05-10 adding HTYPEs

durative-intransitive-verb-lex-super := intransitive-verb-inflected-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT DR ].

durative-intransitive-verb-lex := durative-intransitive-verb-lex-super & htype-normal-verb-lex.

durative-intransitive-location-verb-lex := durative-intransitive-verb-lex-super & htype-location-verb-lex.

perfective-intransitive-verb-lex-super := intransitive-verb-inflected-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT MO ].

perfective-intransitive-verb-lex := perfective-intransitive-verb-lex-super & htype-normal-verb-lex.

perfective-intransitive-location-verb-lex := perfective-intransitive-verb-lex-super & htype-location-verb-lex.

continuative-intransitive-verb-lex := intransitive-verb-inflected-lex & htype-normal-verb-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT CT ].

transitive-no-inflect-verb-lex := transitive-verb-inflected-lex & htype-normal-verb-lex.

transitive-no-inflect-location-verb-lex := transitive-verb-inflected-lex & htype-location-verb-lex.

durative-transitive-verb-lex := transitive-verb-inflected-lex & htype-normal-verb-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT DR ].

perfective-transitive-verb-lex := transitive-verb-inflected-lex & htype-normal-verb-lex & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT MO ].

mood-2p-verb-lex := 2p-lex-no-rels-comp-xarg-raise & 
  [ SYNSEM.LOCAL.CAT [ HEAD verb & [ PRD + ],
                       VAL.SUBJ < [ LOCAL.CAT.HEAD noun ] > ] ].

;mood-strong-real-verb-lex := mood-2p-verb-lex &
;  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD strong-real ].

mood-strong-real-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX [ E.MOOD strong-real,
                                                             SF prop ],
                       MC + ] ].

;;; 2019-03-08 for the verbs that already have aspect & don't need more
main-verb-inflected-lex := main-verb-lex & 
  [ SYNSEM.LOCAL.CAT.HEAD.FORM non-root-nonfinite,
    INFLECTED infl-satisfied ].

main-verb-verb-lex := verb-lex & aspect-1-rule-dtr & aspect-2-rule-dtr & aspect-3-rule-dtr &
  [ SYNSEM.LOCAL.CAT.HEAD.FORM root-nonfinite,
    INFLECTED [ ASPECT-2-FLAG -,
                ASPECT-1-FLAG - ] ].

; Leaving Weak mood underspecified for main clause b/c it is both (replacing neutral) in Q dialect
mood-weak-verb-lex := mood-2p-verb-lex &  aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX [ E.MOOD weak,
                                                             SF prop ] ].

mood-neutral-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX [ E.MOOD neutral,
                                                             SF prop ] ].

mood-unknown-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX [ E.MOOD unknown,
                                                               SF prop ],
                       MC - ] ].

mood-possible-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX [ E.MOOD possible,
                                                               SF prop ],
                       MC - ] ].

mood-hearsay-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX [ E.MOOD hearsay,
                                                               SF prop ],
                       MC + ] ].

mood-inferential-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX [ E.MOOD inferential,
                                                               SF prop ],
                       MC + ] ].

mood-purposive-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX [ E.MOOD purposive,
                                                               SF prop ],
                       MC - ] ].

mood-dubitative-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX [ E.MOOD dubitative,
                                                               SF prop ],
                       MC + ] ].

mood-command-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF comm,
                       MC + ] ].

mood-question-verb-lex := mood-2p-verb-lex & aux-type-raising-dtr & 
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF ques,
                       MC + ] ].

; 2019-04-03 this is a copy of 2p-lex & 2p-verb-lex, plus MC - 
; TODO: should unify and straighten type hierarchy later. What I did:
; I removed the #xarg matching stuff, CONT <! !> was pushed lower, and HEAD verb --> noun, HEAD PRD --> -
; Moved MOD < > lower
; Instead of inheriting from raise-sem-lex-item I inherited from no-hcons-lex-item
; I need: (1) a super type of 2p-lex-super (looks like below) that lacks CONT information, #xarg matching, & no raise-sem-lex-item
; (2) a subtype that adds empty CONT 2p-lex-no-cont 
; (3) a subtype that adds xarg matching and raise-sem-lex
; definite-when-verb inherits from (1), other definite types inherit from (2), all other from (3)
mood-definite-verb-lex-super := no-hcons-lex-item & post-clitic-also-rule-dtr & post-clitic-plural-rule-dtr & pre-clitic-causative-rule-dtr & pre-clitic-future-rule-dtr & pre-clitic-now-rule-dtr & pre-clitic-passive-rule-dtr & pre-clitic-poss-rule-dtr & post-clitic-habitual-lex-rule-dtr & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ FORM finite,
                                         AUX +,
                                         PRD - ],
           VAL [ SUBJ < #subj >,
                 COMPS < #comps . #vcomps >,
                 SPR < >,
                 SPEC < > ],
             MC - ] ],
             NON-LOCAL #nonlocal ],
    ARG-ST < #subj &
       [ LOCAL [ CAT [ HEAD.PRD -,
           VAL.COMPS < > ] ]],
       #comps &
       [ LIGHT +,
         L-PERIPH +,
         OPT -,
         LOCAL [ CAT [ VAL [ SUBJ < #subj >,
                             COMPS #vcomps ],
                       HEAD [ PRD +,
                              FORM nonfinite ],
                       POSTHEAD - ],
                 CONT.HOOK.INDEX.E.MOOD definite ],
         NON-LOCAL #nonlocal ]> ].

mood-definite-verb-raising-lex-super := 2p-lex-no-rels &
  [ SYNSEM.LOCAL.CAT.HEAD.PRD - ].

; 2019-04-03 constraining this to intransitives
mood-definite-subj-raising-verb-lex := mood-definite-verb-raising-lex-super & 
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS < [ LOCAL.CAT [ HEAD verb,
                                                 VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #index ] ] >,
                   CONT.HOOK.INDEX #index ] ].

mood-definite-obj-raising-verb-lex := no-rels-hcons-icons-lex-item & post-clitic-also-rule-dtr & post-clitic-plural-rule-dtr & pre-clitic-causative-rule-dtr & pre-clitic-future-rule-dtr & pre-clitic-now-rule-dtr & pre-clitic-passive-rule-dtr & pre-clitic-poss-rule-dtr & post-clitic-habitual-lex-rule-dtr & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & [ FORM finite,
                                         AUX +,
                                         PRD -,
                                         MOD < > ],
           VAL [ SUBJ < #subj >,
                 COMPS [ FIRST #comps,
                         REST [ FIRST #comp1,
                                REST #comp2 ] ],
                 SPR < >,
                 SPEC < > ],
             MC - ],
             CONT.HOOK.INDEX #comp-index ],
             NON-LOCAL #nonlocal ],
    ARG-ST < #comps &
       [ LIGHT +,
         L-PERIPH +,
         OPT -,
         LOCAL [ CAT [ VAL [ SUBJ < #subj >,
                             COMPS < #comp1 & [ LOCAL.CONT.HOOK.INDEX #comp-index ] . #comp2 > ],
                       HEAD verb & [ PRD +,
                              FORM nonfinite ],
                       POSTHEAD - ] ],
         NON-LOCAL #nonlocal ]> ].

; mood-definite-obj-raising-verb-lex := mood-definite-verb-raising-lex-super & 
;   [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CAT [ HEAD verb,
;                                                    VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #index ],
;                    CONT.HOOK.INDEX #index ] ].

mood-definite-when-verb-lex := 2p-lex & predicate-lex &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ SUBJ < #subj >,
                                 COMPS.FIRST.LOCAL [ CAT.VAL.SUBJ < #subj >,
                                                     CONT.HOOK.INDEX #arg0 ] ],
                         MC -,
                         HEAD verb & [ MOD < [ LOCAL.CONT.HOOK.INDEX #arg1 ] > ] ],
                   CONT [ HOOK [ INDEX #arg0 & [ SF prop ],
                                 XARG #arg1,
                                 LTOP #ltop ],
                          RELS <! [ PRED "when_rel",
                                    LBL #ltop,
                                    ARG0 event & #arg0,
                                    ARG1 event & #arg1 ] !>,
                          HCONS <! !>,
                          ICONS <! !> ] ],
             NON-LOCAL.SLASH <! !> ] ].

;; original:
;; SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 1st,
;;                                                                NUM singular ]
;; TODO: Used to inherit from mood-2p-verb-lex, removed to get definite mood working
1sg-aux-verb-lex := lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 1st,
                                                                                          NUM singular ] ].

1pl-aux-verb-lex := lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 1st,
                                                                NUM plural ] ].

2sg-aux-verb-lex := lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 2nd,
                                                                NUM singular ] ].

2pl-aux-verb-lex := lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG [ PER 2nd,
                                                                NUM plural ] ].

3-aux-verb-lex := lex-item &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.PER 3rd ].

mood-strong-real-1sg-verb-lex := mood-strong-real-verb-lex & 1sg-aux-verb-lex.

mood-strong-real-1pl-verb-lex := mood-strong-real-verb-lex & 1pl-aux-verb-lex.

mood-strong-real-2sg-verb-lex := mood-strong-real-verb-lex & 2sg-aux-verb-lex.

mood-strong-real-2pl-verb-lex := mood-strong-real-verb-lex & 2pl-aux-verb-lex.

mood-strong-real-3-verb-lex := mood-strong-real-verb-lex & 3-aux-verb-lex.

mood-weak-1sg-verb-lex := mood-weak-verb-lex & 1sg-aux-verb-lex.

mood-weak-1pl-verb-lex := mood-weak-verb-lex & 1pl-aux-verb-lex.

mood-weak-2sg-verb-lex := mood-weak-verb-lex & 2sg-aux-verb-lex.

mood-weak-2pl-verb-lex := mood-weak-verb-lex & 2pl-aux-verb-lex.

mood-weak-3-verb-lex := mood-weak-verb-lex & 3-aux-verb-lex.

neutral-mood-1sg-verb-lex := mood-neutral-verb-lex & 1sg-aux-verb-lex.

neutral-mood-1pl-verb-lex := mood-neutral-verb-lex & 1pl-aux-verb-lex.

neutral-mood-2sg-verb-lex := mood-neutral-verb-lex & 2sg-aux-verb-lex.

neutral-mood-2pl-verb-lex := mood-neutral-verb-lex & 2pl-aux-verb-lex.

neutral-mood-3-verb-lex := mood-neutral-verb-lex & 3-aux-verb-lex &
  [ INFLECTED.SOME-INFLECTION - ].

unknown-mood-1sg-verb-lex := mood-unknown-verb-lex & 1sg-aux-verb-lex.

unknown-mood-1pl-verb-lex := mood-unknown-verb-lex & 1pl-aux-verb-lex.

unknown-mood-2sg-verb-lex := mood-unknown-verb-lex & 2sg-aux-verb-lex.

unknown-mood-2pl-verb-lex := mood-unknown-verb-lex & 2pl-aux-verb-lex.

unknown-mood-3-verb-lex := mood-unknown-verb-lex & 3-aux-verb-lex.

possible-mood-1sg-verb-lex := mood-possible-verb-lex & 1sg-aux-verb-lex.

possible-mood-1pl-verb-lex := mood-possible-verb-lex & 1pl-aux-verb-lex.

possible-mood-2sg-verb-lex := mood-possible-verb-lex & 2sg-aux-verb-lex.

possible-mood-2pl-verb-lex := mood-possible-verb-lex & 2pl-aux-verb-lex.

possible-mood-3-verb-lex := mood-possible-verb-lex & 3-aux-verb-lex.

hearsay-mood-1sg-verb-lex := mood-hearsay-verb-lex & 1sg-aux-verb-lex.

hearsay-mood-1pl-verb-lex := mood-hearsay-verb-lex & 1pl-aux-verb-lex.

hearsay-mood-2sg-verb-lex := mood-hearsay-verb-lex & 2sg-aux-verb-lex.

hearsay-mood-2pl-verb-lex := mood-hearsay-verb-lex & 2pl-aux-verb-lex.

hearsay-mood-3-verb-lex := mood-hearsay-verb-lex & 3-aux-verb-lex.

dubitative-mood-3-verb-lex := mood-dubitative-verb-lex & 3-aux-verb-lex.

inferential-mood-3-verb-lex := mood-inferential-verb-lex & 3-aux-verb-lex.

command-mood-2sg-verb-lex := mood-command-verb-lex & 2sg-aux-verb-lex.

command-mood-2pl-verb-lex := mood-command-verb-lex & 2pl-aux-verb-lex.

command-mood-1pl-verb-lex := mood-command-verb-lex & 1pl-aux-verb-lex.

question-mood-1sg-verb-lex := mood-question-verb-lex & 1sg-aux-verb-lex.

question-mood-1pl-verb-lex := mood-question-verb-lex & 1pl-aux-verb-lex.

question-mood-2sg-verb-lex := mood-question-verb-lex & 2sg-aux-verb-lex.

question-mood-2pl-verb-lex := mood-question-verb-lex & 2pl-aux-verb-lex.

question-mood-3-verb-lex := mood-question-verb-lex & 3-aux-verb-lex.

definite-mood-subj-1sg-verb-lex := mood-definite-subj-raising-verb-lex & 1sg-aux-verb-lex.

definite-mood-subj-1pl-verb-lex := mood-definite-subj-raising-verb-lex & 1pl-aux-verb-lex.

definite-mood-subj-2sg-verb-lex := mood-definite-subj-raising-verb-lex & 2sg-aux-verb-lex.

definite-mood-subj-2pl-verb-lex := mood-definite-subj-raising-verb-lex & 2pl-aux-verb-lex.

definite-mood-subj-3-verb-lex := mood-definite-subj-raising-verb-lex & 3-aux-verb-lex.

definite-mood-obj-1sg-verb-lex := mood-definite-obj-raising-verb-lex & 1sg-aux-verb-lex.

definite-mood-obj-1pl-verb-lex := mood-definite-obj-raising-verb-lex & 1pl-aux-verb-lex.

definite-mood-obj-2sg-verb-lex := mood-definite-obj-raising-verb-lex & 2sg-aux-verb-lex.

definite-mood-obj-2pl-verb-lex := mood-definite-obj-raising-verb-lex & 2pl-aux-verb-lex.

definite-mood-obj-3-verb-lex := mood-definite-obj-raising-verb-lex & 3-aux-verb-lex.

definite-mood-when-1sg-verb-lex := mood-definite-when-verb-lex & 1sg-aux-verb-lex.

definite-mood-when-1pl-verb-lex := mood-definite-when-verb-lex & 1pl-aux-verb-lex.

definite-mood-when-2sg-verb-lex := mood-definite-when-verb-lex & 2sg-aux-verb-lex.

definite-mood-when-2pl-verb-lex := mood-definite-when-verb-lex & 2pl-aux-verb-lex.

definite-mood-when-3-verb-lex := mood-definite-when-verb-lex & 3-aux-verb-lex.

transitive-clausal-verbs-verb-lex := main-verb-verb-lex & transitive-verb-lex.

continuative-transitive-verb-lex := transitive-verb-inflected-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT CT ].

repetitive-transitive-verb-lex := transitive-verb-inflected-lex &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT RP ].

;neutral-mood-3-verb-lex := mood-neutral-verb-lex & 3-aux-verb-lex.

;possible-mood-to-modifier-lex-rule := lex-rule &
;  [  ].

;;; Auxiliaries

; 2019-03-29 subj is raised
s-comp-aux := aux-lex & basic-one-arg &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           SPEC < >,
                           SUBJ < #subj >,
                           COMPS < #comps > ],
    ARG-ST < #comps &
             [ LOCAL.CAT [ VAL [ SUBJ < #subj >,
                                 COMPS < > ,
                                 SPR < >,
                                 SPEC < > ],
                           HEAD verb ] ] > ].

; Not inheriting from basic-verb-lex, so need to put in
; event-relation by hand here.

s-comp-aux-with-pred := s-comp-aux & hcons-lex-item &
  [ SYNSEM [ LOCAL.CONT.HCONS <! qeq &
                                 [ HARG #harg,
                                   LARG #larg ] !>,
             LKEYS.KEYREL event-relation &
                          [ ARG1 #harg ] ],
    ARG-ST < [ LOCAL.CONT.HOOK.LTOP #larg ] > ].

; 2019-05-11 making first comp OPT -, only "wik" as in "no" can have a dropped comp.
neg-aux-lex := s-comp-aux-with-pred &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST [ OPT -,
                                       LOCAL.CAT.HEAD [ AUX -,
                                                        FORM nonfinite ] ] ].

;;; Copulas

; 2019-03-23 there is no reason that the complement's subject needs to be null.
; In fact I think it should be cons & equal to the copula's subj. Adding this.
; Also had to remove cat-sat from COMPS < [ LOCAL.CAT ] > 
cop-lex := basic-verb-lex-super & trans-first-arg-raising-lex-item-2 & non-mod-lex-item &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #subj & [ LOCAL [ CONT.HOOK.INDEX #xarg,
                                              CAT cat-sat &
                                                  [ VAL [ SPR < >,
                                                          COMPS < > ],
                                                    HEAD noun ] ] ] >,
                             COMPS < [ LOCAL.CAT [ HEAD [ PRD +,
                                                          MOD < > ],
                                                   VAL [ SUBJ < #subj >,
                                                         COMPS < >,
                                                         SPEC < >,
                                                         SPR < > ] ] ] >,
                             SPR < >,
                             SPEC < > ],
                   CONT.HOOK.XARG #xarg ] ].

; Copula type taking adjectival complements.
; Need to define more for additional complement types.

; 2019-03-23 expanding to include verbs
adj-verb-comp-copula-verb-lex := cop-lex &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD +vj ].

copula-cop-lex := adj-verb-comp-copula-verb-lex.

;;; Adjectives


adj-lex := basic-intersective-adjective-lex & predicate-lex & 
  [ SYNSEM.LOCAL.CAT.HEAD.AUX -,
    INFLECTED infl-satisfied ].

;;; 2019-05-06 POSTHEAD - is causing this to fail for adv =clitics adj. !!
adjective-adj-lex := attr-adj-lex & stative-pred-adj-lex. ;&
;  [ SYNSEM.LOCAL.CAT [ POSTHEAD - ] ].

adjective-adj-pl-lex := adjective-adj-lex & 
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ] > ].

quantifier-adj-lex := attr-adj-lex & stative-pred-adj-lex &
  [ SYNSEM.LOCAL.CAT [ POSTHEAD - ] ].

; Basic attributive adjective definition
; 2019-03-30 TODO: review removed head noun (doesn't have to be) & val.spr cons (should be able to be empty??).
;            instead head.prd + and that's it.
; 2019-03-30 removing PRD + as it doesn't work (as foreseen) with adjective raising. Changing to AUX -.
attr-adj-lex := adj-lex & intersective-mod-lex &
  [ SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [ HEAD.AUX - ] ] > ].

; Stative predicate adjective definition

stative-pred-adj-lex := adj-lex &
  [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < [ LOCAL [ CONT.HOOK.INDEX #xarg,
                                            CAT [ VAL [ SPR < >,
                                                        COMPS < > ],
                                                  HEAD noun ] ] ] >,
                   CONT.HOOK.XARG #xarg ] ].

;;; Complementizers


;;; Adverbs

; 2019-03-22 Same trick where I don't want this applying to bare clitics
; 2019-04-01 adding subj < > to reduce spurious ambiguity with opt subj
; 2019-04-22 making sure non-head-dtr is satisfied
head-adj-scop-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < >,
                                                          COMPS phlist ],
                          NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

adv-lex := basic-scopal-adverb-lex &
  [ SYNSEM.LOCAL.CAT [ VAL [ SPR < >,
                             COMPS < >,
                             SUBJ < > ],
                       HEAD [ MOD < [ LOCAL.CAT.HEAD [ PRD + ] ] >,
                              PRD - ] ] ].

;;;;;;;;;;;;;;;;;;;
;;; Lexical Rules
;;;;;;;;;;;;;;;;;;;

high-or-mid-nominalization-lex-rule := cat-change-with-ccont-lex-rule & same-cont-lex-rule &
  [ SYNSEM.LOCAL [ CONT.HOOK.INDEX event,
                   CAT [ HEAD verb &
                              [ NMZ +,
                                MOD #mod ],
                         VAL [ SUBJ #subj,
                               COMPS #comps,
                               SPR #spr,
                               SPEC #spec ],
                         MC #mc,
                         MKG #mkg,
                         HC-LIGHT #hc-light,
                         POSTHEAD #posthead ] ],
    DTR.SYNSEM.LOCAL.CAT [ HEAD.MOD #mod,
                           VAL [ SUBJ #subj,
                                 COMPS #comps,
                                 SPR #spr,
                                 SPEC #spec ],
                           MC #mc,
                           MKG #mkg,
                           HC-LIGHT #hc-light,
                           POSTHEAD #posthead ],
    C-CONT [ RELS <!  !>,
             HCONS <!  !> ] ].

;;; 2019-05-11 making PRD +, COMPS < >, and DTR root-form
low-nominalization-lex-rule := cat-change-with-ccont-lex-rule & infl-lex-rule &
  [ SYNSEM.LOCAL.CAT [ HEAD noun &
                            [ NMZ +,
                              PRD +,
                              MOD #mod ],
                       VAL [ SUBJ < [ LOCAL [ CAT.VAL.SPR < >,
                                              CONT.HOOK.INDEX #subj ] ] >,
                             SPEC #spec,
                             SPR < [ OPT + ] >,
                             COMPS < > ],
                       MC #mc,
                       MKG #mkg,
                       HC-LIGHT #hc-light,
                       POSTHEAD #posthead ],
    C-CONT [ RELS <! [ PRED "nominalized_rel",
                       LBL #ltop,
                       ARG0 ref-ind & #arg0,
                       ARG1 #arg1 ] !>,
             HCONS <! qeq &
                      [ HARG #arg1,
                        LARG #larg ] !>,
             HOOK [ XARG #xarg,
                    INDEX #arg0,
                    LTOP #ltop ] ],
    DTR.SYNSEM.LOCAL [ CAT [ HEAD [ NMZ -,
                                    MOD #mod,
                                    FORM root ],
                             VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #subj ] >,
                                   SPEC #spec ],
                             MC #mc,
                             MKG #mkg,
                             HC-LIGHT #hc-light,
                             POSTHEAD #posthead ],
                       CONT.HOOK [ XARG #xarg,
                                   LTOP #larg ] ] ].

low-nmz-subjid-compsid-lex-rule := low-nominalization-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL [ COMPS #comps,
                           SUBJ #subj ],
    DTR.SYNSEM.LOCAL.CAT.VAL [ COMPS #comps,
                               SUBJ #subj ] ].

;;; Intermediate rule types

post-clitic-plural-rule-dtr := word-or-lexrule.
pre-clitic-now-rule-dtr := word-or-lexrule.
pre-clitic-poss-rule-dtr := word-or-lexrule.
pre-clitic-passive-rule-dtr := word-or-lexrule.
pre-clitic-future-rule-dtr := word-or-lexrule.
pre-clitic-causative-rule-dtr := word-or-lexrule.
aspect-1-rule-dtr := word-or-lexrule.
aspect-2-rule-dtr := word-or-lexrule.
aspect-3-rule-dtr := word-or-lexrule.
post-clitic-also-rule-dtr := word-or-lexrule.
aux-type-raising-dtr := word-or-lexrule.
post-clitic-habitual-lex-rule-dtr := word-or-lexrule.
2p-suffix-transitive-verb-rule-dtr := word-or-lexrule.
2p-suffix-ditransitive-verb-rule-dtr := word-or-lexrule.
2p-suffix-predcomp-verb-or-uu-rule-dtr := word-or-lexrule.
2p-suffix-predcomp-verb-no-uu-rule-dtr := word-or-lexrule.

;;; Lexical rule types


;;; 2019-04-04 incorporating suffixes

add-incorporation-lex-rule := lex-rule & 
  [ INFLECTED [ CONTINUATIVE-FORM-FLAG #ct-flag,
                ITERATIVE-FORM-FLAG #it-flag,
                MOMENTANEOUS-FORM-FLAG #mo-flag,
                REPETITIVE-FORM-FLAG #rp-flag,
                INCEPTIVE-FORM-FLAG #it-flag,
                INCEPTIVE-COMPLEX-FLAG #in-flag,
                ASPECT-2-FLAG #asp2-flag,
                MOMENTANEOUS-COMPLEX-FLAG #mo-com-flag,
                DURATIVE-FORM-FLAG #dr-flag,
                PRE-CLITIC-PAST-FLAG #cliticpast-flag,
                ASPECT-1-FLAG #asp1-flag,
                SOME-INFLECTION #some-flag,
                INCORPORATION-FLAG + ],
    DTR.INFLECTED [ CONTINUATIVE-FORM-FLAG #ct-flag,
                    ITERATIVE-FORM-FLAG #it-flag,
                    MOMENTANEOUS-FORM-FLAG #mo-flag,
                    REPETITIVE-FORM-FLAG #rp-flag,
                    INCEPTIVE-FORM-FLAG #it-flag,
                    INCEPTIVE-COMPLEX-FLAG #in-flag,
                    ASPECT-2-FLAG #asp2-flag,
                    MOMENTANEOUS-COMPLEX-FLAG #mo-com-flag,
                    DURATIVE-FORM-FLAG #dr-flag,
                    PRE-CLITIC-PAST-FLAG #cliticpast-flag,
                    ASPECT-1-FLAG #asp1-flag,
                    SOME-INFLECTION #some-flag,
                    INCORPORATION-FLAG - ] ].

; HACKY: I am keeping SPEC unspecified 'cause I'm using it as scratch for ditransitives :/
; 2019-04-08 adding that daughter's inflected.incorporation-flag is na-or-- to avoid cyclic application
incorporating-lex-rule := cat-change-only-lex-rule & 
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ < [ LOCAL.CAT.HEAD.PRD - ] >,
                             SPR < > ],
                       HEAD verb & [ PRD +,
                                     AUX -,
                                     FORM non-root-nonfinite,
                                     MOD < > ] ],
    INFLECTED.INCORPORATION-FLAG -,
    DTR.SYNSEM.LOCAL.CAT.HEAD [ NMZ -,
                                AUX - ] ].

noun-incorporation-lex-rule-super := incorporating-lex-rule & 
  [ C-CONT.HCONS <! !>,
    DTR common-noun-word-and-root-lex & [ SYNSEM.LOCAL.CAT.HEAD noun & [ PRD +,
                                                                         MOD < >,
                                                                         FORM root ] ] ].

noun-incorporation-transitive-lex-rule := noun-incorporation-lex-rule-super & 2p-suffix-transitive-verb-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

; HACKY: I am using the SPEC value to store the comps (will need later)
noun-incorporation-ditransitive-lex-rule := noun-incorporation-lex-rule-super & 2p-suffix-ditransitive-verb-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC < #comp2 >,
                           COMPS < #comp2 & [ LOCAL.CAT.POSTHEAD + ] > ] ].

; 2019-04-04 HACKY: I am stuffing the LTOP of the adverb into the GTOP. This may cause problems down the road..
; 2019-04-06 COMP needs to be AUX -. This is not true of adv (which can modify wherever) but it is true of incorporation
; 2019-04-06 making COMP TYPE-RAISE -, this keeps out intransitive-verb-to-adj
adv-incorporation-lex-rule-super := incorporating-lex-rule & 
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST [ LOCAL.CAT [ HEAD [ AUX -,
                                                            TYPE-RAISE - ],
                                                     POSTHEAD + ] ],
                   CONT.HOOK.GTOP #ltop ],
    DTR [ SYNSEM.LOCAL.CAT.HEAD +jr &[ FORM root,
                                       MOD < [ LOCAL.CONT.HOOK.LTOP #ltop ] > ] ] ].

; 2019-04-09 Forcing COMPS COMPS to be null
adv-incorporation-pred-lex-rule := adv-incorporation-lex-rule-super  &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #subj-index ] >,
                               COMPS < [ LOCAL [ CONT.HOOK [ INDEX #index,
                                                                   XARG #subj-index ],
                                                       CAT.VAL.COMPS < > ],
                                               OPT - ] > ],
                   CONT.HOOK [ INDEX #index ] ] ].

adv-and-uu-incorporation-pred-lex-rule := adv-incorporation-pred-lex-rule & 2p-suffix-predcomp-verb-or-uu-rule-dtr.

adv-no-uu-incorporation-pred-lex-rule := adv-incorporation-pred-lex-rule & 2p-suffix-predcomp-verb-no-uu-rule-dtr & 
  [ DTR adv-lex ].

adv-incorporation-ncomp-lex-rule-super := adv-incorporation-lex-rule-super &
  [ SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #xarg,
                   CONT.HOOK.XARG #xarg ],
    DTR.SYNSEM.LOCAL.CAT.HEAD adv ].

adv-incorporation-transitive-lex-rule := adv-incorporation-ncomp-lex-rule-super & 2p-suffix-transitive-verb-rule-dtr & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.REST null ].

; HACKY: I am using the SPEC value to store the 2nd comps (will need later)
adv-incorporation-ditransitive-lex-rule := adv-incorporation-ncomp-lex-rule-super & 2p-suffix-ditransitive-verb-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC < #comp2 >,
                           COMPS.REST [ FIRST #comp2 & synsem-min,
                                        REST null ] ] ].

adj-incorporation-lex-rule-super := incorporating-lex-rule & 
  [ SYNSEM.LOCAL.CAT [ VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #mod-index ],
    C-CONT.HCONS <! !>,
    DTR attr-adj-lex & [ SYNSEM.LOCAL.CAT [ HEAD adj & [ FORM root ],
                                            VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #mod-index ] > ] ] ].

adj-incorporation-transitive-lex-rule := adj-incorporation-lex-rule-super & 2p-suffix-transitive-verb-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.REST null ].

; HACKY: I am using the SPEC value to store the 2nd comps (will need later)
adj-incorporation-ditransitive-lex-rule := adj-incorporation-lex-rule-super & 2p-suffix-ditransitive-verb-rule-dtr &
  [ SYNSEM.LOCAL.CAT.VAL [ SPEC < #comp2 >,
                           COMPS.REST [ FIRST #comp2 & synsem-min,
                                        REST null ] ] ].

pred-incorporation-lex-rule := incorporating-lex-rule & 2p-suffix-predcomp-verb-or-uu-rule-dtr & 2p-suffix-predcomp-verb-no-uu-rule-dtr &
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ < #subj >,
                             COMPS #comps ],
                       HEAD.HTYPE #htype ],
    DTR predicate-lex & [ SYNSEM [ LOCAL.CAT [ HEAD +nvj & [ FORM non-root,
                                                             HTYPE #htype ],
                                  VAL [ SUBJ < #subj >,
                                        COMPS #comps ] ],
                   LIGHT + ] ] ].

empty-uu-lex := no-rels-hcons-icons-lex-item & basic-icons-lex-item & no-icons-lex-item & 
 [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CAT.HEAD.PRD - ] >,
                              COMPS < #mod & [ LOCAL [ CONT.HOOK.INDEX #comp-index,
                                                       CAT [ HEAD.AUX -,
                                                             POSTHEAD + ] ] ] >,
                              SPR < > ],
                        HEAD +jr & [ PRD +,
                                     AUX -,
                                     FORM uu-form,
                                     MOD < #mod > ] ],
                  CONT.HOOK.XARG #comp-index ],
   INFLECTED.INCORPORATION-FLAG - ].

;empty-uu-lex := no-rels-hcons-icons-lex-item & basic-icons-lex-item & no-icons-lex-item & non-mod-lex-item & 
;  [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CAT.HEAD.PRD - ] >,
;                               COMPS.FIRST.LOCAL [ CAT [ HEAD noun & [ PRD - ],
;                                                       POSTHEAD + ],
;                                                   CONT.HOOK.INDEX #comp-index ],
;                               SPR < > ],
;                         HEAD verb & [ PRD +,
;                                       AUX -,
;                                       FORM non-root-nonfinite,
;                                       MOD < > ] ],
;                   CONT.HOOK.XARG #comp-index ],
;    INFLECTED.INCORPORATION-FLAG - ].

;empty-uu-transitive-lex := empty-uu-lex & 2p-suffix-transitive-verb-rule-dtr & 
;  [ SYNSEM.LOCAL.CAT.VAL [ SPEC < >,
;                           COMPS.REST null ] ].

;empty-uu-ditransitive-lex := empty-uu-lex & 2p-suffix-ditransitive-verb-rule-dtr & 
;  [ SYNSEM.LOCAL.CAT.VAL [ SPEC < #comp2 & [ LOCAL.CAT [ HEAD noun,
;                                                POSTHEAD + ] ] >,
;                           COMPS.REST [ FIRST #comp2 & synsem-min,
;                                        REST null ] ] ].

2p-suffix-verb-lex-rule-super := same-light-lex-rule & same-ctxt-lex-rule & same-agr-lex-rule & 
                                 no-hcons-lex-item & no-icons-lex-item & add-incorporation-lex-rule & infl-lex-rule &
  [ SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < #subj & [ LOCAL.CONT.HOOK.INDEX #arg1 ] >,
                             COMPS #comps,
                             SPEC < >,
                             SPR < > ],
                         HEAD verb ],
                   CONT.HOOK [ INDEX #arg0,
                               XARG #arg1,
                               LTOP #lbl ] ],
    C-CONT.RELS <! [ ARG0 event & #arg0,
                     ARG1 ref-ind & #arg1,
                     LBL #lbl ] !>,
    DTR [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #subj >,
                                 COMPS #comps ],
                       CONT.HOOK [ GTOP #lbl ] ] ] ].

2p-suffix-verb-ncomps-lex-rule-super := 2p-suffix-verb-lex-rule-super & predicate-lex &
  [ C-CONT.RELS <! [ ARG2 ref-ind & #arg2 ] !>,
    DTR.SYNSEM.LOCAL.CONT.HOOK.XARG #arg2 ].

;;; 2019-05-11 There is no reason COMPS.FIRST should be PRD +
; SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.PRD +,
2p-suffix-verb-predcomp-lex-rule-super := 2p-suffix-verb-lex-rule-super & same-head-lex-rule & 
  [ C-CONT.RELS <! [ ARG2 event & #arg2 ] !>,
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #arg2 ].

; 2019-04-04 HACKY: using daughter's GTOP to associate with LTOP of the current arg. Probably bad.....
;;; 2019-05-11 making HTYPE normal
2p-suffix-transitive-verb-lex-rule := 2p-suffix-verb-ncomps-lex-rule-super & same-head-lex-rule & 
  [ SYNSEM.LOCAL.CAT.HEAD.HTYPE normal,
    DTR 2p-suffix-transitive-verb-rule-dtr ].

2p-suffix-transitive-verb-lex-rule-uninflected := 2p-suffix-verb-ncomps-lex-rule-super &
  [ INFLECTED [ ASPECT-2-FLAG -,
                ASPECT-1-FLAG - ],
    SYNSEM.LOCAL.CAT.HEAD [ MOD #mod,
                            PRD #prd,
                            HTYPE #htype,
                            FORM root-nonfinite ],
    DTR 2p-suffix-transitive-verb-rule-dtr & [ SYNSEM.LOCAL.CAT.HEAD [ MOD #mod,
                                                                       PRD #prd,
                                                                       HTYPE #htype ] ] ].

2p-suffix-ditransitive-verb-lex-rule := 2p-suffix-verb-ncomps-lex-rule-super &
  [ C-CONT.RELS <! [ ARG3 ref-ind & #arg3 ] !>,
    DTR 2p-suffix-ditransitive-verb-rule-dtr &
      [ SYNSEM.LOCAL [ CAT.VAL [ SPEC < [ LOCAL [ CAT.POSTHEAD +,
                                                  CONT.HOOK.INDEX #arg3 ] ] > ] ] ] ].

2p-suffix-predcomp-verb-lex-rule := 2p-suffix-verb-predcomp-lex-rule-super &
  [ DTR 2p-suffix-predcomp-verb-no-uu-rule-dtr  ].

2p-suffix-predcomp-verb-and-uu-lex-rule := 2p-suffix-verb-predcomp-lex-rule-super &
  [ DTR 2p-suffix-predcomp-verb-or-uu-rule-dtr  ].

go-lex-rule := 2p-suffix-transitive-verb-lex-rule-uninflected & aspect-1-rule-dtr &
  [ C-CONT.RELS <! [ PRED "_go.to_v_rel" ] !> ].

have-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_have_v_rel" ] !> ].

look-for-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_look.for_v_rel" ] !> ].

consume-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_consume_v_rel" ] !> ].

carry-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_carry_v_rel" ] !> ].

times-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_times_v_rel" ] !> ].

find-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_find_v_rel" ] !> ].

take-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_take_v_rel" ] !> ].

talk-about-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_talk.about_v_rel" ] !> ].

go-after-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_go.after_v_rel" ] !> ].

talk-with-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_talk.with_v_rel" ] !> ].

want-involuntary-lex-rule := 2p-suffix-transitive-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_want.involuntarily_v_rel" ] !> ].

give-lex-rule := 2p-suffix-ditransitive-verb-lex-rule &
  [ C-CONT.RELS <! [ PRED "_give_v_rel" ] !> ].

going-to-lex-rule := 2p-suffix-predcomp-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_going.to_v_rel" ] !> ].

want-to-do-lex-rule := 2p-suffix-predcomp-verb-and-uu-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_want.to.do_v_rel" ] !> ].

want-to-involuntary-lex-rule := 2p-suffix-predcomp-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_want.to.involuntarily_v_rel" ] !> ].

do-lex-rule := 2p-suffix-predcomp-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_do_v_rel" ] !> ].

need-to-do-lex-rule := 2p-suffix-predcomp-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_need.to.do_v_rel" ] !> ].

try-to-do-lex-rule := 2p-suffix-predcomp-verb-lex-rule & 
  [ C-CONT.RELS <! [ PRED "_try.to.do_v_rel" ] !> ].

;;; 2019-03-22 allowing intransitive verbs to become adjectives
;;; 2019-05-10 I think this should only be on HTYPE normals (?)
;;; 2019-05-11 Constraining this further to continuous (?)
intransitive-to-int-adj-lex-rule := cat-change-only-lex-rule & 
  [ SYNSEM.LOCAL.CAT [ HEAD adj &
                             [ PRD -,
                               NMZ #nmz,
                               AUX -,
                               MOD < #subj & [ LOCAL intersective-mod ] >,
                               KEYS #keys,
                               POSSESSOR #poss,
                               INIT #init,
                               SPEC-INIT #spec,
                               FORM #form,
                               HTYPE normal,
                               TYPE-RAISE + ],
                           VAL [ SPR < >,
                                 SPEC < >,
                                 SUBJ < >,
                                 COMPS < > ] ],
    DTR [ SYNSEM.LOCAL [ CAT [ HEAD verb & 
                              [ PRD +,
                                NMZ #nmz,
                                AUX -,
                                MOD < >,
                                KEYS #keys,
                                POSSESSOR #poss,
                                INIT #init,
                                SPEC-INIT #spec,
                                FORM #form,
                                HTYPE normal,
                                TYPE-RAISE - ],
                             VAL [ SUBJ < #subj >,
                                   COMPS < >,
                                   SPR < >,
                                   SPEC < > ] ],
                         CONT.HOOK.INDEX.E.ASPECT CT ],
          INFLECTED infl-satisfied ] ].

;;; 2019-03-12 allowing nouns to go through this rule to become individuals
;;; this is the version of the rule that just changes the index
;;; TODO: This started working when I added the C-CONT. WHY!? Investigate...
;;; 2019-04-03 pushing 3rd person info into here!
noun-relativizer-lex-rule := same-non-local-lex-rule & same-modified-lex-rule & same-light-lex-rule & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun & 
                            [ PRD -,
                              NMZ +,
                              AUX -,
                              MOD #mod,
                              KEYS #keys,
                              POSSESSOR #poss,
                              INIT #init,
                              SPEC-INIT #spec,
                              FORM #form ],
                         VAL [ SPEC < >,
                               SUBJ < >,
                               SPR < >,
                               COMPS < > ] ],
                   CONT.HOOK [ INDEX #xarg & [ PNG.PER 3rd ] ] ] ],
    C-CONT [ RELS <! !>,
       HCONS <! !>,
       HOOK.INDEX #xarg & ref-ind ],
    DTR [ INFLECTED infl-satisfied,
          SYNSEM [ LOCAL [ CAT [ HEAD noun &
                               [ PRD +,
                                 NMZ -,
                                 AUX -,
                                 MOD #mod,
                                 KEYS #keys,
                                 POSSESSOR #poss,
                                 INIT #init,
                                 SPEC-INIT #spec,
                                 FORM #form ] ],
                           CONT.HOOK [ XARG #xarg ] ] ] ] ].

;;; 2019-03-19 This rule won't do because because I need to relativize full NPs: naacsiicis iih inii.
;;; this is the version of the rule that adds the nominalized_rel
rel-noun-relativizer-lex-rule := same-non-local-lex-rule & same-modified-lex-rule & same-light-lex-rule &
  [ SYNSEM.LOCAL [ CAT [ HEAD noun & 
                            [ PRD -,
                              NMZ +,
                              AUX -,
                              MOD #mod,
                              KEYS #keys,
                              POSSESSOR #poss,
                              INIT #init,
                              SPEC-INIT #spec,
                              FORM #form ],
                         VAL [ SPR < >,
                               SPEC < >,
                               SUBJ < >,
                               COMPS < > ] ],
                   CONT.HOOK.INDEX #xarg ],
    C-CONT [ RELS <! [ PRED "nominalized_rel",
                       LBL #ltop,
                       ARG0 ref-ind & #arg0,
                       ARG1 #arg1 ] !>,
             HCONS <! qeq &
                      [ HARG #arg1,
                        LARG #larg ] !>,
             HOOK [ XARG #xarg,
                    INDEX #arg0,
                    LTOP #ltop ] ],
    DTR.SYNSEM.LOCAL [ CAT [ HEAD noun &
                               [ PRD +,
                                 NMZ -,
                                 AUX -,
                                 MOD #mod,
                                 KEYS #keys,
                                 POSSESSOR #poss,
                                 INIT #init,
                                 SPEC-INIT #spec,
                                 FORM #form ] ],
                       CONT.HOOK [ XARG #xarg,
                                   LTOP #larg ] ] ].

aspect-1-lex-rule-super := add-only-no-ccont-rule & aspect-2-rule-dtr & aspect-3-rule-dtr & infl-lex-rule &  
  [ INFLECTED [ ASPECT-1-FLAG +,
                INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                PRE-CLITIC-PAST-FLAG #pre-clitic-past,
                ASPECT-2-FLAG #aspect-2,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR aspect-1-rule-dtr &
        [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                      PRE-CLITIC-PAST-FLAG #pre-clitic-past,
                      ASPECT-2-FLAG #aspect-2,
                      MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ] ] ].

momentaneous-form-lex-rule := aspect-1-lex-rule-super &
  [ INFLECTED [ MOMENTANEOUS-FORM-FLAG +,
                CONTINUATIVE-FORM-FLAG #continuative-form,
                ITERATIVE-FORM-FLAG #iterative-form,
                REPETITIVE-FORM-FLAG #repetitive-form,
                INCEPTIVE-FORM-FLAG #inceptive-form,
                DURATIVE-FORM-FLAG #durative-form ],
    DTR.INFLECTED [ CONTINUATIVE-FORM-FLAG #continuative-form,
                    ITERATIVE-FORM-FLAG #iterative-form,
                    REPETITIVE-FORM-FLAG #repetitive-form,
                    INCEPTIVE-FORM-FLAG #inceptive-form,
                    DURATIVE-FORM-FLAG #durative-form ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT momentaneous ].

inceptive-form-lex-rule := aspect-1-lex-rule-super &
  [ INFLECTED [ INCEPTIVE-FORM-FLAG +,
                CONTINUATIVE-FORM-FLAG #continuative-form,
                ITERATIVE-FORM-FLAG #iterative-form,
                MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                REPETITIVE-FORM-FLAG #repetitive-form,
                DURATIVE-FORM-FLAG #durative-form ],
    DTR.INFLECTED [ CONTINUATIVE-FORM-FLAG #continuative-form,
                    ITERATIVE-FORM-FLAG #iterative-form,
                    MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                    REPETITIVE-FORM-FLAG #repetitive-form,
                    DURATIVE-FORM-FLAG #durative-form ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT inceptive ].

continuative-form-lex-rule := aspect-1-lex-rule-super &
  [ INFLECTED [ CONTINUATIVE-FORM-FLAG +,
                ITERATIVE-FORM-FLAG #iterative-form,
                MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                REPETITIVE-FORM-FLAG #repetitive-form,
                INCEPTIVE-FORM-FLAG #inceptive-form,
                DURATIVE-FORM-FLAG #durative-form ],
    DTR.INFLECTED [ ITERATIVE-FORM-FLAG #iterative-form,
                    MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                    REPETITIVE-FORM-FLAG #repetitive-form,
                    INCEPTIVE-FORM-FLAG #inceptive-form,
                    DURATIVE-FORM-FLAG #durative-form ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT continuative ].

durative-form-lex-rule := aspect-1-lex-rule-super &
  [ INFLECTED [ DURATIVE-FORM-FLAG +,
                CONTINUATIVE-FORM-FLAG #continuative-form,
                ITERATIVE-FORM-FLAG #iterative-form,
                REPETITIVE-FORM-FLAG #repetitive-form,
                INCEPTIVE-FORM-FLAG #inceptive-form,
                MOMENTANEOUS-FORM-FLAG #momentaneous-form ],
    DTR.INFLECTED [ CONTINUATIVE-FORM-FLAG #continuative-form,
                    ITERATIVE-FORM-FLAG #iterative-form,
                    REPETITIVE-FORM-FLAG #repetitive-form,
                    INCEPTIVE-FORM-FLAG #inceptive-form,
                    MOMENTANEOUS-FORM-FLAG #momentaneous-form ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT durative ].

repetitive-form-lex-rule := aspect-1-lex-rule-super &
  [ INFLECTED [ REPETITIVE-FORM-FLAG +,
                CONTINUATIVE-FORM-FLAG #continuative-form,
                ITERATIVE-FORM-FLAG #iterative-form,
                MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                INCEPTIVE-FORM-FLAG #inceptive-form,
                DURATIVE-FORM-FLAG #durative-form ],
    DTR.INFLECTED [ CONTINUATIVE-FORM-FLAG #continuative-form,
                    ITERATIVE-FORM-FLAG #iterative-form,
                    MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                    INCEPTIVE-FORM-FLAG #inceptive-form,
                    DURATIVE-FORM-FLAG #durative-form ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT repetitive ].

iterative-form-lex-rule := aspect-1-lex-rule-super &
  [ INFLECTED [ ITERATIVE-FORM-FLAG +,
                CONTINUATIVE-FORM-FLAG #continuative-form,
                MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                REPETITIVE-FORM-FLAG #repetitive-form,
                INCEPTIVE-FORM-FLAG #inceptive-form,
                DURATIVE-FORM-FLAG #durative-form ],
    DTR.INFLECTED [ CONTINUATIVE-FORM-FLAG #continuative-form,
                    MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                    REPETITIVE-FORM-FLAG #repetitive-form,
                    INCEPTIVE-FORM-FLAG #inceptive-form,
                    DURATIVE-FORM-FLAG #durative-form ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT iterative ].

aspect-2-lex-rule-super := add-only-no-ccont-rule & 2p-suffix-predcomp-verb-no-uu-rule-dtr & 2p-suffix-predcomp-verb-or-uu-rule-dtr &
  [ INFLECTED [ ASPECT-2-FLAG +,
                CONTINUATIVE-FORM-FLAG #continuative-form,
                ITERATIVE-FORM-FLAG #iterative-form,
                MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                REPETITIVE-FORM-FLAG #repetitive-form,
                INCEPTIVE-FORM-FLAG #inceptive-form,
                DURATIVE-FORM-FLAG #durative-form,
                PRE-CLITIC-PAST-FLAG #pre-clitic-past,
                ASPECT-1-FLAG #aspect-1 ],
    DTR aspect-2-rule-dtr &
        [ INFLECTED [ CONTINUATIVE-FORM-FLAG #continuative-form,
                      ITERATIVE-FORM-FLAG #iterative-form,
                      MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                      REPETITIVE-FORM-FLAG #repetitive-form,
                      INCEPTIVE-FORM-FLAG #inceptive-form,
                      DURATIVE-FORM-FLAG #durative-form,
                      PRE-CLITIC-PAST-FLAG #pre-clitic-past,
                      ASPECT-1-FLAG #aspect-1 ] ] ].

repetitive-perfective-lex-rule := aspect-2-lex-rule-super & infl-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ REPETITIVE-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                    MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT RP-PF ].

repetitive-lex-rule := aspect-2-lex-rule-super & const-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ REPETITIVE-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                    MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT RP ].

momentaneous-lex-rule := aspect-2-lex-rule-super & aspect-3-rule-dtr & const-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ MOMENTANEOUS-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                    MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT MO ].

inceptive-lex-rule := aspect-2-lex-rule-super & const-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ INCEPTIVE-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                    MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT IN ].

momentaneous-complex-lex-rule := aspect-2-lex-rule-super & infl-lex-rule &
  [ INFLECTED [ MOMENTANEOUS-COMPLEX-FLAG +,
                INCEPTIVE-COMPLEX-FLAG #inceptive-complex ],
    DTR.INFLECTED [ MOMENTANEOUS-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex ] ].

continuative-lex-rule := aspect-2-lex-rule-super & const-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ CONTINUATIVE-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                    MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT CT ].

inceptive-complex-lex-rule := aspect-2-lex-rule-super & infl-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG +,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ] ].

durative-perfective-lex-rule := aspect-2-lex-rule-super & infl-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ DURATIVE-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                    MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT DR-PF ].

durative-lex-rule := aspect-2-lex-rule-super & const-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ DURATIVE-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                    MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT DR ].

iterative-perfective-lex-rule := aspect-2-lex-rule-super & infl-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ ITERATIVE-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                    MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ] ].

iterative-lex-rule := aspect-2-lex-rule-super & const-lex-rule &
  [ INFLECTED [ INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    DTR.INFLECTED [ ITERATIVE-FORM-FLAG +,
                    INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                    MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ],
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT IT ].

aspect-3-lex-rule-super := add-only-no-ccont-rule & 2p-suffix-predcomp-verb-no-uu-rule-dtr & 2p-suffix-predcomp-verb-or-uu-rule-dtr &
  [ INFLECTED #infl,
    DTR aspect-3-rule-dtr &
        [ INFLECTED #infl ] ].

momentaneous-graduative-perfective-lex-rule := aspect-3-lex-rule-super & infl-lex-rule &
  [ DTR.INFLECTED.MOMENTANEOUS-COMPLEX-FLAG +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT MO-GRAD-PF ].

inceptive-graduative-lex-rule := aspect-3-lex-rule-super & const-lex-rule &
  [ DTR.INFLECTED.INCEPTIVE-COMPLEX-FLAG +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT IN-GRAD ].

momentaneous-graduative-lex-rule := aspect-3-lex-rule-super & const-lex-rule &
  [ DTR.INFLECTED.MOMENTANEOUS-COMPLEX-FLAG +,
    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT MO-GRAD ].

inceptive-graduative-perfective-lex-rule := aspect-3-lex-rule-super & infl-lex-rule &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT IN-GRAD-PF ].

clitic-inflection-lex-rule-super := lex-rule &
  [ INFLECTED [ PRE-CLITIC-PAST-FLAG #pre-clitic-past,
                CONTINUATIVE-FORM-FLAG #continuative-form,
                ASPECT-2-FLAG #aspect-2,
                ITERATIVE-FORM-FLAG #iterative-form,
                MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                REPETITIVE-FORM-FLAG #repetitive-form,
                INCEPTIVE-FORM-FLAG #inceptive-form,
                INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                ASPECT-1-FLAG #aspect-1,
                DURATIVE-FORM-FLAG #durative-form,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex,
                SOME-INFLECTION + ],
    DTR.INFLECTED [ PRE-CLITIC-PAST-FLAG #pre-clitic-past,
                CONTINUATIVE-FORM-FLAG #continuative-form,
                ASPECT-2-FLAG #aspect-2,
                ITERATIVE-FORM-FLAG #iterative-form,
                MOMENTANEOUS-FORM-FLAG #momentaneous-form,
                REPETITIVE-FORM-FLAG #repetitive-form,
                INCEPTIVE-FORM-FLAG #inceptive-form,
                INCEPTIVE-COMPLEX-FLAG #inceptive-complex,
                ASPECT-1-FLAG #aspect-1,
                DURATIVE-FORM-FLAG #durative-form,
                MOMENTANEOUS-COMPLEX-FLAG #momentaneous-complex ] ].

post-clitic-habitual-lex-rule-super := clitic-inflection-lex-rule-super & add-only-no-ccont-rule & infl-lex-rule & post-clitic-also-rule-dtr & post-clitic-plural-rule-dtr & aux-type-raising-dtr &
  [ DTR post-clitic-habitual-lex-rule-dtr ].

;; 2019-03-06 Changed commented line to get it to compile, investigate later
habitual-lex-rule := post-clitic-habitual-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.E.ASPECT habitual ].
;    SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT habitual ].

post-clitic-plural-lex-rule-super := clitic-inflection-lex-rule-super & add-only-no-ccont-rule & infl-lex-rule & post-clitic-also-rule-dtr & aux-type-raising-dtr &
  [ DTR post-clitic-plural-rule-dtr ].

clitic-plural-lex-rule := post-clitic-plural-lex-rule-super &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX.PNG.NUM plural ].

pre-clitic-past-lex-rule-super := clitic-inflection-lex-rule-super & add-only-no-ccont-rule & infl-lex-rule & pre-clitic-causative-rule-dtr & pre-clitic-future-rule-dtr & pre-clitic-now-rule-dtr & pre-clitic-passive-rule-dtr & pre-clitic-poss-rule-dtr & aux-type-raising-dtr & post-clitic-habitual-lex-rule-dtr & post-clitic-plural-rule-dtr & post-clitic-also-rule-dtr &
  [ DTR mood-2p-verb-lex ].

past-lex-rule := pre-clitic-past-lex-rule-super & 
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.TENSE past ].

pre-clitic-poss-lex-rule-super := clitic-inflection-lex-rule-super & pre-clitic-causative-rule-dtr & pre-clitic-future-rule-dtr & pre-clitic-now-rule-dtr & pre-clitic-passive-rule-dtr  & aux-type-raising-dtr & post-clitic-habitual-lex-rule-dtr & post-clitic-plural-rule-dtr & post-clitic-plural-rule-dtr & post-clitic-also-rule-dtr &
  [ DTR pre-clitic-poss-rule-dtr ].

; 2019-04-18 removing while fixing causative
;clitic-poss-intrans-lex-rule := causative-to-arg2-itr-op-lex-rule & infl-lex-rule & pre-clitic-poss-lex-rule-super & same-non-local-lex-rule.
;  [ C-CONT.RELS <! [ PRED "POSS" ] !> ].

clitic-poss-lex-rule-super := pre-clitic-poss-lex-rule-super & same-non-local-lex-rule & infl-lex-rule & val-change-with-ccont-lex-rule.
;  [ C-CONT.RELS <! [ PRED "POSS" ] !> ].

clitic-poss-normal-lex-rule := clitic-poss-lex-rule-super & poss-rel-lex-rule-normal.

clitic-poss-defn-lex-rule := clitic-poss-lex-rule-super & poss-rel-lex-rule-defn.

pre-clitic-passive-lex-rule-super := clitic-inflection-lex-rule-super & infl-lex-rule & pre-clitic-causative-rule-dtr & pre-clitic-future-rule-dtr & pre-clitic-now-rule-dtr & val-change-with-ccont-lex-rule & aux-type-raising-dtr & post-clitic-habitual-lex-rule-dtr & post-clitic-plural-rule-dtr & post-clitic-also-rule-dtr &
  [ DTR pre-clitic-passive-rule-dtr ].

clitic-passive-lex-rule := passive-lex-rule & pre-clitic-passive-lex-rule-super.

pre-clitic-now-lex-rule-super := clitic-inflection-lex-rule-super & add-only-no-ccont-rule & infl-lex-rule & pre-clitic-causative-rule-dtr & pre-clitic-future-rule-dtr & aux-type-raising-dtr & post-clitic-habitual-lex-rule-dtr & post-clitic-plural-rule-dtr & post-clitic-also-rule-dtr &
  [ DTR pre-clitic-now-rule-dtr ].

clitic-now-lex-rule := pre-clitic-now-lex-rule-super.

pre-clitic-causative-lex-rule-super := clitic-inflection-lex-rule-super & infl-lex-rule & pre-clitic-future-rule-dtr & val-change-with-ccont-lex-rule & aux-type-raising-dtr & post-clitic-habitual-lex-rule-dtr & post-clitic-plural-rule-dtr & post-clitic-also-rule-dtr &
  [ DTR pre-clitic-causative-rule-dtr ].

; 2019-04-18 PRED is now higher up
;clitic-causative-intrans-lex-rule := causative-to-arg2-itr-op-lex-rule & pre-clitic-causative-lex-rule-super & same-non-local-lex-rule &
;  [ C-CONT.RELS <! [ PRED "CAUS" ] !> ].

clitic-causative-trans-lex-rule := causal-rel-lex-rule & pre-clitic-causative-lex-rule-super & same-non-local-lex-rule.
;  [ C-CONT.RELS <! [ PRED "CAUS" ] !> ].

pre-clitic-future-lex-rule-super := clitic-inflection-lex-rule-super & add-only-no-ccont-rule & infl-lex-rule & aux-type-raising-dtr & post-clitic-plural-rule-dtr & post-clitic-also-rule-dtr & post-clitic-also-rule-dtr &
  [ DTR pre-clitic-future-rule-dtr ].

clitic-future-lex-rule := pre-clitic-future-lex-rule-super &
  [ DTR.INFLECTED.PRE-CLITIC-PAST-FLAG na,
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.E.TENSE future ].

post-clitic-also-lex-rule-super := clitic-inflection-lex-rule-super & add-only-no-ccont-rule & infl-lex-rule & aux-type-raising-dtr &
  [ DTR post-clitic-also-rule-dtr ].

clitic-also-lex-rule := post-clitic-also-lex-rule-super.

subj-dem-to-arg3of3-op-lex-rule := subj-and-comps-change-only-lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #oarg,
                                 [ LOCAL.CONT.HOOK.INDEX #sidx ] >,
    DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #sidx ] >,
                               COMPS < #oarg,
                                       [ ] > ] ].

passive-lex-rule := subj-comps-xarg-only-lex-rule &
  [ SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #firstcomp & [ LOCAL.CONT.HOOK.INDEX #osubjindex ] >,
                             COMPS [ FIRST [ LOCAL [ CAT [ VAL [ SUBJ < #subj & [ LOCAL.CONT.HOOK.INDEX #newsubj ] >,
                                                                 COMPS [ FIRST #firstcomp,
                                                                         REST #vcomps ],
                                                                 SPR #spr,
                                                                 SPEC #spec ],
                                                           HEAD #head,
                                                           MC #mc,
                                                           POSTHEAD #posthead ],
                                                     CONT [ RELS #rels,
                                                            HCONS #hcons,
                                                            ICONS #icons,
                                                            HOOK [ LTOP #ltop,
                                                                   GTOP #gtop,
                                                                   INDEX #index,
                                                                   XARG #newsubj,
                                                                   ICONS-KEY #ikey,
                                                                   CLAUSE-KEY #ckey ] ] ],
                                         OPT #opt,
                                         LIGHT #light,
                                         L-PERIPH #l-periph,
                                         R-PERIPH #r-periph ],
                                 REST [ FIRST #subj,
                                        REST #vcomps ] ] ],
                   CONT.HOOK.XARG #osubjindex ],
    DTR.SYNSEM.LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #osubjindex ] >,
                                 COMPS [ FIRST [ LOCAL [ CAT [ VAL [ SPR #spr,
                                                                   SPEC #spec ],
                                                             HEAD #head,
                                                             MC #mc,
                                                             POSTHEAD #posthead ],
                                                         CONT [ RELS #rels,
                                                                HCONS #hcons,
                                                                ICONS #icons,
                                                                HOOK [ LTOP #ltop,
                                                                       GTOP #gtop,
                                                                       INDEX #index,
                                                                       ICONS-KEY #ikey,
                                                                       CLAUSE-KEY #ckey ] ] ],
                                              OPT #opt,
                                              LIGHT #light,
                                              L-PERIPH #l-periph,
                                              R-PERIPH #r-periph ] ] ] ] ].

scopal-rel-lex-rule := lex-rule &
  [ C-CONT [ RELS <! event-relation &
                     [ LBL #ltop,
                       ARG0 #hidx,
                       ARG1 #arg1,
                       ARG2 #arg2,
                       ARG3 #harg ] !>,
             HOOK [ LTOP #ltop,
                    INDEX #hidx,
                    XARG #arg1 ],
             HCONS <! qeq &
                      [ HARG #harg,
                        LARG #scoped ] !> ],
    SYNSEM.LOCAL.CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #arg1 ] >,
    DTR.SYNSEM.LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #arg2 ] >,
                       CONT.HOOK.LTOP #scoped ] ].

; 2019-04-18
; DTR: SUBJ < #subj >, COMPS < pred & [ SUBJ < #subj > ] >
; New: SUBJ < #subj >, COMPS < pred & #pred [ SUBJ < #lower-subj > ], part & #lower-subj >, CAUS(#subj, qeq-#pred)
causal-rel-lex-rule := lex-rule &
  [ C-CONT [ RELS <! event-relation &
                     [ LBL #ltop,
                       PRED "CAUS",
                       ARG0 #arg0,
                       ARG1 #causer,
                       ARG2 #harg ] !>,
             HOOK [ LTOP #ltop,
                    INDEX #arg0,
                    XARG #causer ],
             HCONS <! qeq &
                      [ HARG #harg,
                        LARG #scoped ] !> ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj >,
                           SPR < >,
                           SPEC < >,
                           COMPS [ FIRST [ LIGHT +,
                                           L-PERIPH +,
                                           OPT -,
                                           LOCAL [ CAT [ VAL [ SUBJ < #caused-event-subj >,
                                                               COMPS #vcomps ],
                                                        HEAD [ PRD +,
                                                               FORM nonfinite ],
                                                         POSTHEAD - ],
                                                   CONT.HOOK.LTOP #scoped ] ],
                                   REST [ FIRST #caused-event-subj,
                                          REST #vcomps ] ] ],
    DTR.SYNSEM.LOCAL [ CAT.VAL [ SUBJ < #subj & [ LOCAL.CONT.HOOK.INDEX #causer ] >,
                                 COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #arg0 ] ] ].


; 2019-04-22 moving the dtr's index to my index
poss-rel-lex-rule-super := lex-rule &
  [ C-CONT [ RELS <! event-relation &
                     [ PRED "POSS",
                       ARG0 event,
                       ARG1 #possessor,
                       ARG2 #possessum ] !>,
             HOOK [ LTOP #ltop,
                    XARG #possessor ],
             HCONS <! !> ],
    SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj & [ LOCAL.CONT.HOOK.INDEX #possessum ] >,
                           SPR < >,
                           SPEC < >,
                           COMPS [ FIRST [ LIGHT +,
                                           L-PERIPH +,
                                           OPT -,
                                           LOCAL [ CAT [ VAL [ SUBJ < #subj >,
                                                               COMPS #vcomps ],
                                                         HEAD [ PRD +,
                                                                FORM nonfinite ],
                                                         POSTHEAD - ] ] ],
                                   REST [ FIRST [ LOCAL [ CONT.HOOK.INDEX #possessor,
                                                          CAT.POSTHEAD + ] ],
                                          REST #vcomps ] ] ],
    DTR.SYNSEM.LOCAL [ CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX #possessor ] > ],
                       CONT.HOOK [ LTOP #ltop ] ] ].
;                       CONT.HOOK.INDEX #clitic-index ] ].

poss-rel-lex-rule-normal := poss-rel-lex-rule-super &
  [ C-CONT.HOOK.INDEX #index,
    DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #index & [ E.MOOD non-definite ] ].

poss-rel-lex-rule-defn := poss-rel-lex-rule-super &
  [ C-CONT.HOOK.INDEX #index,
    SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.XARG #index,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.E.MOOD definite ].

;;;;;;;;;;;;;;;;;;;
;;; Lexical rules
;;;;;;;;;;;;;;;;;;;

subj-comps-xarg-only-lex-rule := same-spec-lex-rule & 
                                 same-spr-lex-rule & 
                                 same-head-lex-rule &
                                 same-hc-light-lex-rule &
                                 same-posthead-lex-rule &
                                 same-mc-lex-rule &
                                 local-change-only-lex-rule &
                                 same-ctxt-lex-rule &
                                 same-agr-lex-rule &
  [ C-CONT.HOOK [ INDEX #index,
                  LTOP #ltop,
                  GTOP #gtop,
                  ICONS-KEY #ikey,
                  CLAUSE-KEY #ckey ],
    DTR.SYNSEM.LOCAL.CONT.HOOK [ INDEX #index,
                                 LTOP #ltop,
                                 GTOP #gtop,
                                 ICONS-KEY #ikey,
                                 CLAUSE-KEY #ckey ] ].

;;;;;;;;;;;;;;;;;;;
;;; Phrasal Types
;;;;;;;;;;;;;;;;;;;

; 2019-03-31 Extraction types

basic-extracted-arg-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ PRD + ] ].

basic-extracted-adj-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ AUX +,
                                                                 PRD + ] ].

; extracted comp must be PH + (i.e., not the comp of a 2p aux)
; 2019-04-01 can only extract 1 arg at a time: i.e., if everything else is satisfied. can constrain other VAL lists to < >.
nuk-extracted-comp-phrase := basic-extracted-comp-phrase & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ olist,
                                    COMPS < [ LOCAL.CAT.POSTHEAD + ] > ] ].

; 2019-04-09 can't inherit from matrix type because it asserts MC na (need it to be silent on the matter)
; also need to say that the head-dtr is AUX +
nuk-extracted-subj-phrase := basic-extracted-arg-phrase & head-compositional &
  [ SYNSEM.LOCAL.CAT [ VAL [ SUBJ < >,
                             SPR < >,
                             COMPS < > ],
                       MC #mc ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ < gap &
                                             [ LOCAL.CONT.HOOK.INDEX ref-ind,
                                               NON-LOCAL.SLASH #slash ] >,
                                        COMPS < > ],
                                  HEAD.AUX +,
                                  MC #mc ],
                      NON-LOCAL.SLASH #slash ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
             ICONS <! !> ] ].

; TODO: constrain extracted adj to be quantifiers
nuk-extracted-adj-phrase := extracted-adj-phrase.

; despite a HEAD-DTR with SUBJ < > the subj of the mother is not defined? Adding SUBJ < > to mother
; 2019-04-01 I think I only want this to extract from clausal auxes (aux + prd +) & filler should be prd -
; hacky but am requiring it to apply immediately after extraction :/
; 2019-04-09 removing requirement that daughter be AUX + and form finite --- this is for things like aanahimah nuuk unaak
nuk-filler-head-phrase := basic-head-filler-phrase & head-final & 
  [ SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR basic-extracted-arg-phrase & [ SYNSEM.LOCAL.CAT [ HEAD [ 
                                       PRD + ],
                                VAL #val & [ COMPS < >,
                                      SPEC < >,
                                      SPR < > ] ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.PRD - ].

; 2019-03-23 Need to make sure adjectives don't apply to the left of the 2P article
adj-head-int-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.AUX - ].

;2019-03-23 Doing the same to adj-head-scop-phrase
;;; TODO: This is blocking things like tanaqas nunuukinaaa
;;; 2019-05-11 making non-head-dtr COMPS < >, constrains attachment (TODO: Not sure if this blocks other things)
adj-head-scop-phrase :+ [ HEAD-DTR.SYNSEM.LOCAL.CAT [ HEAD.AUX -,
                                                      VAL.COMPS < > ] ].

;2019-03-30
;2019-03-31 moving this into the lexical rule set
auxiliary-type-raise-super := local-change-only-lex-rule & same-agr-lex-rule & same-ctxt-lex-rule & 
  [ SYNSEM.LOCAL [ CAT [ HEAD [ TYPE-RAISE +, 
                                AUX +,
                                PRON #pron,
                                NMZ #nmz,
                                FORM #form,
                                MOD #mod ],
                         VAL [ SPEC < >,
                               SPR < >,
                               COMPS [ FIRST [ LOCAL.CAT [ HEAD [ MOD cons,
                                                                  AUX - ],
                                                     POSTHEAD - ],
                                               OPT -,
                                               L-PERIPH + ],
                                       REST [ FIRST [ LOCAL [ CAT [ HEAD #head,
                                                                   MC #mc,
                                                                   MKG #mkg,
                                                                   HC-LIGHT #hc-light,
                                                                   POSTHEAD + ],
                                                             CONT #cont,
                                                             AGR #agr,
                                                             COORD #coord ],
                                                     OPT #opt,
                                                     NON-LOCAL #nonlocal ],
                                              REST #rcomp ] ] ] ] ],
    C-CONT [ RELS  <! !>,
             HCONS <! !>,
             ICONS <! !> ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ VAL [ COMPS [FIRST [ LOCAL [ CAT [ HEAD #head,
                                                                     MC #mc,
                                                                     MKG #mkg,
                                                                     HC-LIGHT #hc-light,
                                                                     POSTHEAD - ],
                                                               CONT #cont,
                                                               AGR #agr,
                                                               COORD #coord ],
                                                       OPT #opt,
                                                       NON-LOCAL #nonlocal ],
                                               REST #rcomp ],
                                        SPEC < >,
                                        SPR < > ],
                                  HEAD verb & [ TYPE-RAISE -,
                                         AUX +,
                                         PRON #pron,
                                         NMZ #nmz,
                                         FORM #form,
                                         MOD #mod ] ] ],
             INFLECTED infl-satisfied ] > ].

; 2019-03-19 
; 2019-04-01 removing the PRD + and changing to adverb - -- because clitics need to to attach to advs.
type-raise-clausal-clitic-lex-rule := auxiliary-type-raise-super & 
  [ SYNSEM.LOCAL [ CAT [ HEAD verb & [ PRD +,
                                       HTYPE #htype ],
                         VAL [ SUBJ < #subj >,
                               COMPS [ FIRST.LOCAL.CAT.HEAD adv & [ MOD < #fcomp & [ LOCAL.CAT.HEAD.HTYPE #htype ] > ],
                                       REST [ FIRST #fcomp,
                                              REST null ] ] ] ],
                 CONT.HOOK #hook ],
    ARGS < aux-type-raising-dtr & [ SYNSEM.LOCAL [ CAT.VAL.SUBJ < #subj >,
                                                   CONT.HOOK #hook ] ] > ].

; 2019-03-30 comps comps should always be null under this type, don't know how it becomes contentful.
type-raise-article-lex-rule := auxiliary-type-raise-super &
  [ SYNSEM.LOCAL [ CAT [ HEAD noun & [ PRD - ],
                         VAL [ SUBJ < >,
                               COMPS [ FIRST.LOCAL.CAT.HEAD.MOD < #mod & [ LOCAL.CONT.HOOK #hook ] >,
                                       REST.FIRST.LOCAL.CAT.VAL [ SUBJ < #mod >,
                                                                  COMPS #vcomps,
                                                                  SPR < >,
                                                                  SPEC < > ] ] ] ],
                 CONT.HOOK #hook ],
    ARGS < article-lex & [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < #mod >,
                                                  COMPS.FIRST.LOCAL.CAT.VAL.COMPS #vcomps ] ] > ].

; 2019-04-01

;;; 2019-03-13 Defining daughter's co mps.first as posthead or null,
;;; to prevent this from firing on POSTHEAD - (i.e., 2P's first COMP)
;;; 2019-04-01 think this should also require head-dtr to be aux +
;;; 2019-04-04 removing HEAD.AUX + requirement on daughter, may need to add back.
head-comp-phrase := nuk-head-1st-comp-phrase & head-initial-head-nexus &
  [ SYNSEM.LIGHT -,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL.COMPS phlist ] ].

nf-comp-head-phrase := head-nf-comp-phrase-super & head-final-head-nexus &
  [ SYNSEM [ L-PERIPH +,
             INFOSTR-FLAG + ],
    HEAD-DTR.SYNSEM.LIGHT +,
    NON-HEAD-DTR.SYNSEM [ L-PERIPH +,
                          LOCAL [ CAT.HEAD +np,
                                  CONT.HOOK.ICONS-KEY focus ] ] ].

nf-subj-head-phrase := head-nf-subj-phrase-super & head-final-head-nexus &
  [ SYNSEM [ L-PERIPH +,
             INFOSTR-FLAG + ],
    HEAD-DTR.SYNSEM.LIGHT +,
    NON-HEAD-DTR.SYNSEM [ L-PERIPH +,
                          LOCAL [ CAT.HEAD +np,
                                  CONT.HOOK.ICONS-KEY focus ] ] ].

head-nf-subj-phrase-super := basic-head-subj-phrase & declarative-clause & narrow-focus &
  [ NON-HEAD-DTR.SYNSEM.INFOSTR-FLAG + ].

head-nf-comp-phrase-super := basic-head-comp-phrase & narrow-focus &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < #synsem . #comps >,
    NON-HEAD-DTR.SYNSEM #synsem &
                        [ INFOSTR-FLAG + ] ].

narrow-focused-phrase := head-only &
  [ C-CONT [ HOOK #hook,
             RELS <!  !>,
             HCONS <!  !>,
             ICONS <! focus-or-topic & #icons &
                      [ IARG2 #target ] !> ],
    SYNSEM [ LIGHT -,
             INFOSTR-FLAG +,
             LOCAL [ CAT.VAL [ SPR < >,
                               SUBJ < >,
                               COMPS < >,
                               SPEC < > ],
                     CONT.HOOK [ INDEX #target,
                                 ICONS-KEY #icons ] ] ],
    HEAD-DTR.SYNSEM [ LIGHT -,
                      INFOSTR-FLAG -,
                      LOCAL [ CAT.HEAD noun,
                              CONT [ HOOK #hook,
                                     ICONS <!  !> ] ] ] ].

;;; 2019-04-01 what the hell is this?
head-subj-phrase-2 := basic-head-subj-phrase & declarative-clause & head-initial &
  [ HEAD-DTR.SYNSEM [ INFOSTR-FLAG +,
                      LIGHT -,
                      LOCAL.CAT.VAL.COMPS < > ],
    NON-HEAD-DTR.SYNSEM.INFOSTR-FLAG - ].

;;; 2019-03-13 Defining comps as posthead or null,
;;; to prevent this from firing if there is a POSTHEAD - element (i.e., 2P's first COMP)
;;; 2019-03-30 changing from phlist to olist (??)
;;; 2019-04-23 changing back to phlist (??)
head-comp-phrase-2 := nuk-head-2nd-comp-phrase & head-initial-head-nexus &
  [ SYNSEM [ LIGHT -,
             LOCAL.CAT.VAL.COMPS phlist ] ].

;;; 2019-03-13 Defining daughter's comps as posthead or null,
;;; to prevent this from firing if there is a POSTHEAD - element (i.e., 2P's first COMP)
;;; 2019-04-09 think this is unneeded
;head-comp-phrase-3 := nuk-head-1st-comp-phrase & head-initial &
;  [ HEAD-DTR.SYNSEM [ INFOSTR-FLAG +,
;                      LIGHT -,
;                      LOCAL.CAT.VAL [ SUBJ < >,
;                                      COMPS phlist ] ],
;    NON-HEAD-DTR.SYNSEM.INFOSTR-FLAG - ].

high-nominalized-clause-phrase := unary-phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD noun &
                                [ NMZ +,
                                  MOD < > ],
                           VAL [ SPR < [ OPT + ] >,
                                 COMPS < >,
                                 SUBJ < >,
                                 SPEC < > ] ],
                     COORD - ],
             NON-LOCAL #nl ],
    C-CONT [ RELS <! [ PRED "nominalized_rel",
                       LBL #ltop,
                       ARG0 ref-ind & #arg0,
                       ARG1 #arg1 ] !>,
             HCONS <! qeq &
                      [ HARG #arg1,
                        LARG #larg ] !>,
             HOOK [ XARG #xarg,
                    INDEX #arg0,
                    LTOP #ltop ] ],
    ARGS < [ SYNSEM [ NON-LOCAL #nl,
                      LOCAL [ CAT [ HEAD verb &
                                         [ NMZ + ],
                                    VAL [ COMPS < >,
                                          SUBJ < >,
                                          SPR < >,
                                          SPEC < > ] ],
                              CONT.HOOK [ XARG #xarg,
                                          LTOP #larg ],
                              COORD - ] ] ] > ].

;;; TODO: generated by GM, is this necessary?

non-event-subj-head-phrase := head-final-head-nexus & basic-head-subj-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX ref-ind,
                      NON-LOCAL [ QUE 0-dlist,
                                  REL 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < > ].

;;; TODO: ditto.

non-event-head-subj-phrase := head-initial-head-nexus & basic-head-subj-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK.INDEX ref-ind,
                      NON-LOCAL [ QUE 0-dlist,
                                  REL 0-dlist ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < > ].

verbal-head-nexus := headed-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb ].

;;; 2019-03-12 Removing "& na" from #mc. This was created by the V2 req in the GM I think. 
head-initial-head-nexus := head-initial &
  [ SYNSEM.LOCAL.CAT.MC #mc,
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

; removing MC na, also generated by V2 I think.
head-final-head-nexus := head-final &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD - ].
;  [ SYNSEM.LOCAL.CAT.MC luk ].
;    HEAD-DTR.SYNSEM.LOCAL.CAT.MC na ].

;;; 2019-03-13 Defining daughter's comps as posthead or null,
;;; to prevent this from firing if there is a POSTHEAD - element (i.e., 2P's first COMP)
;;; 2019-03-19 I *think* HEAD should always be a clausal clitic: AUX + PRD +
head-subj-phrase := decl-head-subj-phrase & head-initial-head-nexus &
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD [ AUX +,
                                     PRD + ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.PRD -,
    SYNSEM.LOCAL.CAT.VAL.COMPS phlist ].

;;; 2019-03-12 constraining subj to be PRD -
subj-head-phrase := decl-head-subj-phrase & head-final-head-nexus &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.PRD - ].

;;; 2019-04-09 need to make the parent of comp-head-phrases the parent LIGHT - so AUX composition can't apply after
;;; copying from matrix.tdl & modifying LIGHT.
nuk-head-comp-phrase := head-valence-phrase & head-compositional &
              binary-headed-phrase & 
  [ SYNSEM phr-synsem-min &
           [ LOCAL.CAT [ VAL [ SUBJ #subj,
                               SPEC #spec,
                               SPR #spr ],
                         POSTHEAD #ph,
                         HC-LIGHT #light ],
             LIGHT - ],
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ VAL [ SUBJ #subj,
                                        SPEC #spec,
                                        SPR #spr ],
                                  HC-LIGHT #light,
                                  POSTHEAD #ph ]],
    NON-HEAD-DTR.SYNSEM canonical-synsem,
    C-CONT [ RELS <! !>, HCONS <! !>, ICONS <! !> ] ].

nuk-head-1st-comp-phrase := nuk-head-comp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < #synsem . #comps >,
    NON-HEAD-DTR.SYNSEM #synsem ].

nuk-head-2nd-comp-phrase := basic-head-comp-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #firstcomp . #othercomps >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS [ FIRST #firstcomp,
                                          REST < #synsem . #othercomps > ],
    NON-HEAD-DTR.SYNSEM #synsem ].

;;; 2019-09-04 should only be allowed for AUX & MC -.
;;; Default phrase is not passing up MC information which is odd.
comp-head-phrase := nuk-head-1st-comp-phrase & head-final-head-nexus &
  [ SYNSEM.LOCAL.CAT.MC #mc,
    HEAD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].

aux-composition-phrase := comp-head-phrase &
  [ HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD.AUX +,
                      LIGHT + ] ].

comp-head-subordinate-phrase := comp-head-phrase &
  [ SYNSEM.LOCAL.CAT.MC -,
    HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.AUX - ].

;;; 2019-03-13 Defining comps as posthead or null,
;;; to prevent this from firing if there is a POSTHEAD - element (i.e., 2P's first COMP)
;;; 2019-04-23 changing this from phlist to olist
comp-head-phrase-2 := nuk-head-2nd-comp-phrase & head-final-head-nexus &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS olist ].

poss-unary-phrase-1 := poss-unary-phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.SPEC-INIT -,
                       VAL.SPEC.FIRST.LOCAL.CAT.POSSESSUM possessum-1 ] ].

head-spec-phrase := head-initial & basic-head-spec-phrase &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPEC < [ LOCAL.CAT.POSSESSUM #poss ] >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.POSSESSUM #poss ].

;;; TODO: Fix this, POSS should introduce a REL, be an aux
poss-unary-phrase := basic-unary-phrase &
  [ SYNSEM.LOCAL [ CONT.HOOK #hook,
                   CAT [ HEAD det &
                              [ POSSESSOR possessor ],
                         VAL [ SPR < >,
                               COMPS < >,
                               SUBJ < >,
                               SPEC < [ LOCAL [ CAT [ VAL.COMPS < >,
                                                      HEAD noun &
                                                           [ PRON - ] ],
                                                CONT.HOOK #hook &
                                                          [ INDEX #possessum &
                                                                  [ COG-ST uniq-id ],
                                                            LTOP #lbl ] ] ] > ] ] ],
    C-CONT [ RELS <! arg12-ev-relation &
                     [ PRED "poss_rel",
                       LBL #lbl,
                       ARG1 #possessum,
                       ARG2 #possessor ], quant-relation &
                                          [ PRED "exist_q_rel",
                                            ARG0 #possessum,
                                            RSTR #harg ] !>,
             HCONS <! qeq &
                      [ HARG #harg,
                        LARG #lbl ] !>,
             ICONS <!  !> ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ VAL [ SPR < >,
                                        COMPS < >,
                                        SUBJ < >,
                                        SPEC < > ],
                                  HEAD +np ],
                            CONT.HOOK.INDEX #possessor ] ] > ].

poss-unary-phrase-2 := poss-unary-phrase &
  [ SYNSEM.LOCAL.CAT [ HEAD.SPEC-INIT -,
                       VAL.SPEC.FIRST.LOCAL.CAT.POSSESSUM possessum-2 ] ].

; Bare NP phrase.  Consider modifying the PRED value of the quantifier relation
; introduced to match the semantic effect of bare NPs in your language.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].

;;;;;;;;;;;;;;;;;;
;;; Coordination
;;;;;;;;;;;;;;;;;;

;;; Coordination Strategy 1

n1-top-coord-rule := basic-n-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

n1-mid-coord-rule := basic-n-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

n1-bottom-coord-rule := conj-first-bottom-coord-rule & n-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

;;; Coordination Strategy 2

n2-top-coord-rule := basic-n-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

n2-bottom-coord-rule := conj-first-bottom-coord-rule & n-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "2" ].

;;; Coordination Strategy 3

vp3-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "3" ].

vp3-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "3" ].

vp3-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "3" ].

;;; Coordination Strategy 4

vp4-top-coord-rule := basic-vp-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "4" ].

vp4-bottom-coord-rule := conj-first-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "4" ].

;;; Coordination Strategy 5

s5-top-coord-rule := basic-s-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

s5-mid-coord-rule := basic-s-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

s5-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

;;; 2019-05-06 SVC strategies

svc-coord-phrase := binary-phrase &
  [ SYNSEM [ LOCAL [ COORD-STRAT #cstrat,
                   CAT [ HEAD.MOD #mod,
                         VAL #val ] ],
             NON-LOCAL #nl ],
    LCOORD2-DTR #ldtr & sign & [ SYNSEM [ LOCAL [ CAT [ HEAD.MOD #mod,
                                                        VAL #val & [ COMPS phlist ] ],
                                                 CONT.HOOK [ INDEX [ E [ MOOD #mood,
                                                                         TENSE #tense ] ],
                                                             LTOP #lhndl ] ],
                                         NON-LOCAL #nl ] ],
    RCOORD2-DTR #rdtr & sign & [ SYNSEM [ LOCAL [ COORD-STRAT #cstrat,
                                                  COORD-REL [ L-HNDL #lhndl,
                                                              R-HNDL #rhndl,
                                                              R-INDEX.E [ MOOD #mood,
                                                                          TENSE #tense ] ],
                                                  CONT.HOOK.LTOP #rhndl,
                                                  CAT [ HEAD.MOD #mod,
                                                        VAL.COMPS phlist ] ],
           NON-LOCAL #nl ] ],
    ARGS < #ldtr, #rdtr > ].

svc-top-coord-rule := svc-coord-phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD #head,
                         VAL [ SUBJ < #subj >,
                               COMPS #comps ] ] ],
    LCOORD2-DTR.SYNSEM.LOCAL [ COORD -,
                               CAT [ HEAD #head & verb & [ AUX + ],
                                    VAL [ SUBJ < #subj >,
                                          COMPS #comps & phlist ] ],
                               CONT.HOOK.INDEX #lind & [ SF #sf,
                                                         E [ MOOD #mood,
                                                             TENSE #tense ] ] ],
    RCOORD2-DTR.SYNSEM.LOCAL [ COORD +,
                               COORD-REL [ LBL #lbl,
                                           C-ARG #carg,
                                           L-INDEX #lind,
                                           R-INDEX #rind ],
                               CAT [ HEAD verb & [ AUX - ],
                                     VAL.SUBJ < #subj > ],
                               CONT.HOOK.INDEX #rind & [ E [ MOOD #mood,
                                                             TENSE #tense ] ] ],
    C-CONT [ HOOK [ LTOP #lbl,
                    INDEX #carg & [ SF #sf ] ],
             RELS <! !>,
             HCONS <! !> ] ].

svc-bottom-coord-phrase := bottom-coord-phrase &
  [ SYNSEM.LOCAL [ CAT [ HEAD verb,
                         VAL.SUBJ < #subj > ],
                   CONT.HOOK.INDEX.E.MOOD #mood ],
    NONCONJ-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb,
                                     VAL [ SUBJ < #subj >,
                                           COMPS < > ] ],
                               CONT.HOOK.INDEX.E.MOOD #mood ] ].

;;; specific SVCs

;;; Type 1: No perf matching

svc1-bottom-coord-rule := unary-bottom-coord-rule & svc-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "6",
                   COORD-REL.PRED "_meanwhile_coord_rel" ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ FORM nonfinite,
                                                 HTYPE normal ] ] ].

svc1-top-coord-rule := svc-top-coord-rule & 
  [ SYNSEM.LOCAL [ COORD -,
                   COORD-STRAT "6",
                   CAT.HEAD.HTYPE normal ] ].

;;; Type 2: location

svc2-bottom-coord-rule := unary-bottom-coord-rule & svc-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "7",
                   COORD-REL.PRED "_meanwhile_coord_rel" ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ FORM nonfinite ] ] ].


svc2-top-coord-rule := svc-top-coord-rule & 
  [ SYNSEM.LOCAL [ COORD -,
                   COORD-STRAT "7",
                   CAT.HEAD.HTYPE location ] ].


;;; Type 3: adpositive

svc3-bottom-coord-rule := unary-bottom-coord-rule & svc-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "8",
                   COORD-REL.PRED "_meanwhile_coord_rel" ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ FORM nonfinite ] ] ].


svc3-top-coord-rule := svc-top-coord-rule & 
  [ SYNSEM.LOCAL [ COORD -,
                   COORD-STRAT "8",
                   CAT.HEAD.HTYPE adpositive ] ].


svc3-2-bottom-coord-rule := unary-bottom-coord-rule & svc-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "8.5",
                   COORD-REL.PRED "_meanwhile_coord_rel" ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ FORM nonfinite,
                                                 HTYPE adpositive ] ] ].


svc3-2-top-coord-rule := svc-top-coord-rule & 
  [ SYNSEM.LOCAL [ COORD -,
                   COORD-STRAT "8.5" ] ].

;;; Type 4: and

svc4-bottom-coord-rule := unary-bottom-coord-rule & svc-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "9",
                   COORD-REL.PRED "_and_coord_rel" ],
    NONCONJ-DTR.SYNSEM.LOCAL.CAT [ HEAD verb & [ FORM nonfinite,
                                                 HTYPE normal ] ] ].

svc4-top-coord-rule := svc-top-coord-rule & 
  [ SYNSEM.LOCAL [ COORD -,
                   COORD-STRAT "9",
                   CAT.HEAD.HTYPE normal ] ].